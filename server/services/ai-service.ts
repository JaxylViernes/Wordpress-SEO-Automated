// server/services/ai-service.ts

import OpenAI from "openai";
import Anthropic from "@anthropic-ai/sdk";
import { storage } from "../storage";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { imageService } from "./image-service";
import { CloudinaryStorageService } from "./cloudinary-storage";

// Initialize Cloudinary storage
const cloudinaryStorage = new CloudinaryStorageService();

// AI Provider Configuration
export type AIProvider = "openai" | "anthropic" | "gemini";

// Initialize AI providers
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY_ENV_VAR,
});

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY!,
});

const gemini = process.env.GOOGLE_GEMINI_API_KEY
  ? new GoogleGenerativeAI(process.env.GOOGLE_GEMINI_API_KEY)
  : null;

// Model configurations
const AI_MODELS = {
  openai: {
    model: "gpt-4o",
    pricing: {
      input: 0.005,
      output: 0.015,
    },
  },
  anthropic: {
    model: process.env.ANTHROPIC_MODEL || "claude-sonnet-4-20250514",
    pricing: {
      input: 0.003,
      output: 0.015,
    },
  },
  gemini: {
    model: "gemini-1.5-flash",
    pricing: {
      input: 0.0025,
      output: 0.0075,
    },
  },
} as const;

export interface ContentGenerationRequest {
  websiteId: string;
  topic: string;
  keywords: string[];
  tone: "professional" | "casual" | "friendly" | "authoritative" | "technical" | "warm";
  wordCount: number;
  seoOptimized: boolean;
  brandVoice?: string;
  targetAudience?: string;
  eatCompliance?: boolean;
  aiProvider: AIProvider;
  userId: string;
  includeImages?: boolean;
  imageCount?: number;
  imageStyle?: "natural" | "digital_art" | "photographic" | "cinematic";
  isAutoGenerated?: boolean;
  autoScheduleId?: string;
  autoPublish?: boolean;
  publishDelay?: number;
}

export interface ContentGenerationResultWithPublishing extends ContentGenerationResult {
  contentId?: string;
  published?: boolean;
  scheduledForPublishing?: boolean;
  publishedAt?: Date;
  scheduledDate?: Date;
  totalCost?: string;
  title?: string;
}

export interface ContentAnalysisRequest {
  title: string;
  content: string;
  keywords: string[];
  tone: string;
  brandVoice?: string;
  targetAudience?: string;
  eatCompliance?: boolean;
  websiteId: string;
  aiProvider: AIProvider;
  userId: string;
}

export interface ContentGenerationResult {
  title: string;
  content: string;
  excerpt: string;
  metaDescription: string;
  metaTitle: string;
  keywords: string[];
  seoScore: number;
  readabilityScore: number;
  brandVoiceScore: number;
  eatCompliance: boolean;
  tokensUsed: number;
  costUsd: number;
  aiProvider: AIProvider;
  qualityChecks: {
    plagiarismRisk: "low" | "medium" | "high";
    factualAccuracy: "verified" | "needs_review" | "questionable";
    brandAlignment: "excellent" | "good" | "needs_improvement";
  };
  images?: Array<{
    url: string;
    filename: string;
    altText: string;
    prompt: string;
    cost: number;
    cloudinaryUrl?: string;
    cloudinaryPublicId?: string;
  }>;
  totalImageCost?: number;
}

export interface ContentAnalysisResult {
  seoScore: number;
  readabilityScore: number;
  brandVoiceScore: number;
  tokensUsed: number;
  costUsd: number;
  aiProvider: AIProvider;
}

// Custom error classes
export class AIProviderError extends Error {
  constructor(provider: AIProvider, message: string) {
    super(`${provider.toUpperCase()} Error: ${message}`);
    this.name = "AIProviderError";
  }
}

export class AnalysisError extends Error {
  constructor(analysisType: string, message: string) {
    super(`${analysisType} Analysis Error: ${message}`);
    this.name = "AnalysisError";
  }
}

export class ContentFormatter {
  static convertMarkdownToHtml(content: string): string {
    return content
      .replace(/^######\s+(.+)$/gm, "<h6>$1</h6>")
      .replace(/^#####\s+(.+)$/gm, "<h5>$1</h5>")
      .replace(/^####\s+(.+)$/gm, "<h4>$1</h4>")
      .replace(/^###\s+(.+)$/gm, "<h3>$1</h3>")
      .replace(/^##\s+(.+)$/gm, "<h2>$1</h2>")
      .replace(/^#\s+(.+)$/gm, "<h1>$1</h1>")
      .replace(/^######\s+(.+?)\s*$/gm, "<h6>$1</h6>")
      .replace(/^#####\s+(.+?)\s*$/gm, "<h5>$1</h5>")
      .replace(/^####\s+(.+?)\s*$/gm, "<h4>$1</h4>")
      .replace(/^###\s+(.+?)\s*$/gm, "<h3>$1</h3>")
      .replace(/^##\s+(.+?)\s*$/gm, "<h2>$1</h2>")
      .replace(/^#\s+(.+?)\s*$/gm, "<h1>$1</h1>");
  }

  static convertMarkdownFormatting(content: string): string {
    return content
      .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
      .replace(/__(.*?)__/g, "<strong>$1</strong>")
      .replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, "<em>$1</em>")
      .replace(/(?<!_)_([^_]+?)_(?!_)/g, "<em>$1</em>")
      .replace(/^[\-\‚Ä¢\‚óÜ\*\+]\s+(.+)$/gm, "<li>$1</li>")
      .replace(/^\d+\.\s+(.+)$/gm, "<li>$1</li>");
  }

  static wrapListItems(content: string): string {
    content = content.replace(
      /(<li>.*?<\/li>(?:\s*<li>.*?<\/li>)*)/gs,
      (match) => {
        if (match.includes("<li>")) {
          return `<ul>\n${match}\n</ul>`;
        }
        return match;
      }
    );
    return content;
  }

  static formatForWordPress(content: string): string {
    let formatted = content;
    formatted = this.convertMarkdownToHtml(content);
    formatted = this.convertMarkdownFormatting(formatted);
    formatted = this.wrapListItems(formatted);
    formatted = this.addParagraphTags(formatted);
    formatted = this.addHeaderSpacing(formatted);
    formatted = this.addProperSpacing(formatted);
    return formatted;
  }

  private static addParagraphTags(content: string): string {
    const blocks = content.split("\n\n");
    return blocks
      .map((block) => {
        const trimmed = block.trim();
        if (!trimmed) return "";
        if (trimmed.startsWith("<") && trimmed.endsWith(">")) {
          return trimmed;
        }
        if (trimmed.match(/^<h[1-6]>/)) {
          return trimmed;
        }
        return `<p>${trimmed}</p>`;
      })
      .join("\n\n");
  }

  private static addProperSpacing(content: string): string {
    return content
      .replace(/(<h[1-6]>.*?<\/h[1-6]>)/g, "\n$1\n")
      .replace(/(<\/?(?:ul|ol)>)/g, "\n$1\n")
      .replace(/\n{3,}/g, "\n\n")
      .trim();
  }

  private static addHeaderSpacing(content: string): string {
    return content
      .replace(/(<h[1-6]>.*?<\/h[1-6]>)/g, "\n$1\n")
      .replace(/\n{3,}/g, "\n\n");
  }
}

export class AIService {
  async analyzeExistingContent(request: {
    title: string;
    content: string;
    keywords: string[];
    tone: string;
    brandVoice?: string;
    targetAudience?: string;
    eatCompliance?: boolean;
    websiteId: string;
    aiProvider: AIProvider;
    userId: string;
  }): Promise<ContentAnalysisResult> {
    try {
      console.log(`Re-analyzing existing content with ${request.aiProvider.toUpperCase()}`);

      const analysisResult = await this.performContentAnalysis({
        title: request.title,
        content: request.content,
        keywords: request.keywords,
        tone: request.tone,
        brandVoice: request.brandVoice,
        targetAudience: request.targetAudience,
        eatCompliance: request.eatCompliance || false,
        websiteId: request.websiteId,
        aiProvider: request.aiProvider,
        userId: request.userId,
      });

      console.log(
        `‚úÖ Existing content re-analyzed - SEO: ${analysisResult.seoScore}%, Readability: ${analysisResult.readabilityScore}%, Brand Voice: ${analysisResult.brandVoiceScore}%`
      );

      return analysisResult;
    } catch (error: any) {
      console.error("Failed to analyze existing content:", error);
      if (error instanceof AIProviderError || error instanceof AnalysisError) {
        throw error;
      }
      throw new AnalysisError(
        "Content Re-analysis",
        error.message || "Unknown error during content analysis"
      );
    }
  }

  public async callOpenAI(
    messages: any[],
    responseFormat?: any,
    temperature = 0.7
  ): Promise<{ content: string; tokens: number }> {
    if (!process.env.OPENAI_API_KEY && !process.env.OPENAI_API_KEY_ENV_VAR) {
      throw new AIProviderError("openai", "API key not configured in environment variables");
    }

    try {
      const response = await openai.chat.completions.create({
        model: AI_MODELS.openai.model,
        messages,
        response_format: responseFormat,
        temperature,
      });

      const content = response.choices[0]?.message?.content;
      if (!content) {
        throw new AIProviderError("openai", "No content returned from API");
      }

      return {
        content,
        tokens: response.usage?.total_tokens || 0,
      };
    } catch (error: any) {
      if (error instanceof AIProviderError) throw error;

      if (error.status === 401) {
        throw new AIProviderError(
          "openai",
          "Invalid API key. Please check your OpenAI API key configuration."
        );
      } else if (error.status === 429) {
        throw new AIProviderError("openai", "Rate limit exceeded. Please try again later.");
      } else if (error.status === 403) {
        throw new AIProviderError(
          "openai",
          "Insufficient permissions. Please check your OpenAI API key permissions."
        );
      }

      throw new AIProviderError("openai", error.message || "Unknown API error");
    }
  }

  public embedImagesInContent(
    content: string,
    images: Array<{
      url: string;
      filename: string;
      altText: string;
      prompt: string;
      cost: number;
    }>
  ): string {
    return this.embedImagesInContentPrivate(content, images);
  }

  private embedImagesInContentPrivate(
    content: string,
    images: Array<{
      url: string;
      filename: string;
      altText: string;
      prompt: string;
      cost: number;
      cloudinaryUrl?: string;
    }>
  ): string {
    if (!images || images.length === 0) {
      return content;
    }

    let modifiedContent = content;

    images.forEach((image, index) => {
      // Use Cloudinary URL if available, otherwise fallback to original URL
      const imageUrl = image.cloudinaryUrl || image.url;
      
      const imageHtml = `
<figure class="wp-block-image size-large">
  <img src="${imageUrl}" alt="${image.altText}" class="wp-image" style="max-width: 100%; height: auto;" />
  <figcaption>${image.altText}</figcaption>
</figure>
`;

      if (index === 0) {
        const firstParagraphEnd = modifiedContent.indexOf("</p>");
        if (firstParagraphEnd !== -1) {
          modifiedContent =
            modifiedContent.slice(0, firstParagraphEnd + 4) +
            "\n\n" +
            imageHtml +
            "\n\n" +
            modifiedContent.slice(firstParagraphEnd + 4);
          console.log(`üñºÔ∏è Placed hero image after introduction`);
        } else {
          modifiedContent = imageHtml + "\n\n" + modifiedContent;
          console.log(`üñºÔ∏è Placed hero image at beginning (fallback)`);
        }
      } else {
        const h2Regex = /<h2>/g;
        const h2Matches = Array.from(modifiedContent.matchAll(h2Regex));

        if (h2Matches.length > index - 1) {
          const insertPoint = h2Matches[index - 1].index;
          modifiedContent =
            modifiedContent.slice(0, insertPoint) +
            imageHtml +
            "\n\n" +
            modifiedContent.slice(insertPoint);
          console.log(`üñºÔ∏è Placed image ${index + 1} before H2 section`);
        } else {
          const conclusionHeadings = ["<h2>Conclusion", "<h2>Summary", "<h2>Final"];
          let insertPoint = -1;

          for (const heading of conclusionHeadings) {
            insertPoint = modifiedContent.lastIndexOf(heading);
            if (insertPoint !== -1) break;
          }

          if (insertPoint !== -1) {
            modifiedContent =
              modifiedContent.slice(0, insertPoint) +
              imageHtml +
              "\n\n" +
              modifiedContent.slice(insertPoint);
            console.log(`üñºÔ∏è Placed image ${index + 1} before conclusion`);
          } else {
            modifiedContent = modifiedContent + "\n\n" + imageHtml;
            console.log(`üñºÔ∏è Placed image ${index + 1} at end (fallback)`);
          }
        }
      }
    });

    return modifiedContent;
  }

  private async callGemini(
    messages: any[],
    temperature = 0.7
  ): Promise<{ content: string; tokens: number }> {
    if (!process.env.GOOGLE_GEMINI_API_KEY || !gemini) {
      throw new AIProviderError("gemini", "API key not configured in environment variables");
    }

    try {
      const model = gemini.getGenerativeModel({
        model: AI_MODELS.gemini.model,
      });

      const systemMessage = messages.find((m) => m.role === "system");
      const userMessages = messages.filter((m) => m.role === "user" || m.role === "assistant");

      const history = userMessages.slice(0, -1).map((m) => ({
        role: m.role === "user" ? "user" : "model",
        parts: [{ text: m.content }],
      }));

      const lastMessage = userMessages[userMessages.length - 1];
      if (!lastMessage || lastMessage.role !== "user") {
        throw new AIProviderError(
          "gemini",
          "Invalid message format - last message must be from user"
        );
      }

      const chat = model.startChat({
        history,
        generationConfig: {
          temperature,
          maxOutputTokens: 4000,
        },
      });

      let prompt = lastMessage.content;
      if (systemMessage?.content) {
        prompt = `${systemMessage.content}\n\n${prompt}`;

        if (systemMessage.content.includes("JSON") || systemMessage.content.includes("json")) {
          prompt +=
            "\n\nIMPORTANT: You must respond with valid JSON only. Do not include any text before or after the JSON object. Start your response with { and end with }.";
        }
      }

      const result = await chat.sendMessage(prompt);
      const response = await result.response;
      const responseText = response.text();

      if (!responseText) {
        throw new AIProviderError("gemini", "No content returned from API");
      }

      let cleanedText = responseText.trim();

      if (!cleanedText.startsWith("{") && cleanedText.includes("{")) {
        const jsonStart = cleanedText.indexOf("{");
        const jsonEnd = cleanedText.lastIndexOf("}") + 1;
        if (jsonStart !== -1 && jsonEnd > jsonStart) {
          cleanedText = cleanedText.substring(jsonStart, jsonEnd);
        }
      }

      const estimatedTokens = Math.ceil((prompt.length + cleanedText.length) / 4);

      return {
        content: cleanedText,
        tokens: estimatedTokens,
      };
    } catch (error: any) {
      if (error instanceof AIProviderError) throw error;

      if (error.status === 429 || error.message?.includes("Too Many Requests")) {
        throw new AIProviderError(
          "gemini",
          "Rate limit exceeded. Google Gemini free tier allows only 15 requests/minute and 1,500/day. " +
            "Please wait a few minutes or consider upgrading to a paid plan. " +
            "Alternatively, use OpenAI or Anthropic for now."
        );
      } else if (error.message?.includes("API_KEY_INVALID")) {
        throw new AIProviderError(
          "gemini",
          "Invalid API key. Please check your Google Gemini API key configuration."
        );
      }

      throw new AIProviderError("gemini", error.message || "Unknown API error");
    }
  }

  private async callAnthropic(
    messages: any[],
    temperature = 0.7
  ): Promise<{ content: string; tokens: number }> {
    if (!process.env.ANTHROPIC_API_KEY) {
      throw new AIProviderError("anthropic", "API key not configured in environment variables");
    }

    try {
      const systemMessage = messages.find((m) => m.role === "system");
      const userMessages = messages.filter((m) => m.role === "user" || m.role === "assistant");

      let systemContent = systemMessage?.content || "";
      if (systemContent.includes("JSON") || systemContent.includes("json")) {
        systemContent +=
          "\n\nIMPORTANT: You must respond with valid JSON only. Do not include any text before or after the JSON object. Start your response with { and end with }.";
      }

      const response = await anthropic.messages.create({
        model: AI_MODELS.anthropic.model,
        max_tokens: 4000,
        temperature,
        system: systemContent,
        messages: userMessages.map((m) => ({
          role: m.role === "user" ? "user" : "assistant",
          content: m.content,
        })),
      });

      const content = response.content[0];
      if (content.type !== "text" || !content.text) {
        throw new AIProviderError("anthropic", "No text content returned from API");
      }

      let responseText = content.text.trim();

      if (!responseText.startsWith("{") && responseText.includes("{")) {
        const jsonStart = responseText.indexOf("{");
        const jsonEnd = responseText.lastIndexOf("}") + 1;
        if (jsonStart !== -1 && jsonEnd > jsonStart) {
          responseText = responseText.substring(jsonStart, jsonEnd);
        }
      }

      return {
        content: responseText,
        tokens: response.usage.input_tokens + response.usage.output_tokens,
      };
    } catch (error: any) {
      if (error instanceof AIProviderError) throw error;

      if (error.status === 401) {
        throw new AIProviderError(
          "anthropic",
          "Invalid API key. Please check your Anthropic API key configuration."
        );
      } else if (error.status === 429) {
        throw new AIProviderError("anthropic", "Rate limit exceeded. Please try again later.");
      }

      throw new AIProviderError("anthropic", error.message || "Unknown API error");
    }
  }

  private async callAI(
    provider: AIProvider,
    messages: any[],
    responseFormat?: any,
    temperature = 0.7
  ): Promise<{ content: string; tokens: number }> {
    switch (provider) {
      case "openai":
        return this.callOpenAI(messages, responseFormat, temperature);
      case "anthropic":
        return this.callAnthropic(messages, temperature);
      case "gemini":
        return this.callGemini(messages, temperature);
      default:
        throw new Error(`Unsupported AI provider: ${provider}`);
    }
  }

  async generateContent(
    request: ContentGenerationRequest
  ): Promise<ContentGenerationResultWithPublishing> {
    try {
      console.log(
        `Generating content for user ${request.userId} with ${request.aiProvider.toUpperCase()}`
      );

      if (request.isAutoGenerated) {
        console.log(`Auto-generation detected:`, {
          autoScheduleId: request.autoScheduleId,
          autoPublish: request.autoPublish,
          publishDelay: request.publishDelay,
        });
      }

      // Step 1: Check if image generation is requested
      if (request.includeImages && request.imageCount && request.imageCount > 0) {
        if (!process.env.OPENAI_API_KEY && !process.env.OPENAI_API_KEY_ENV_VAR) {
          throw new Error("Image generation requires OpenAI API key for DALL-E 3");
        }
        console.log(
          `üé® Will generate ${request.imageCount} images with DALL-E 3 (regardless of content AI provider: ${request.aiProvider})`
        );
      }

      // Step 2: Generate the actual content
      const contentPrompt = this.buildContentPrompt(request);

      const systemPrompt = `Okay, real talk. You're that friend who actually knows their shit about ${request.topic} because you've been in the trenches for years. Not the guru type‚Äîthe person who's failed enough times to know what actually works.

Write like you're explaining this to someone smart who just asked you for the real story. They don't need the Wikipedia version. They need the "here's what nobody tells you" version.

=== YOUR VOICE CALIBRATION ===
You're not writing. You're talking. Big difference.
- Interrupt yourself when you realize something: "Actually, wait‚Äîbefore I explain that..."
- Correct yourself: "No, that's not quite right. What I mean is..."
- Show uncertainty: "I think it's around 73%? Maybe 74%. Let me explain why that matters..."
- Get excited about the interesting parts: "Oh, and this part is actually super interesting..."
- Brief tangents that loop back: "Reminds me of when... but anyway, back to the point"

=== CRITICAL ANTI-PATTERN RULES ===
NEVER use these (they scream AI):
- Starting with "In today's..." or "In the world of..." or "In this article..."
- Transitions: Moreover, Furthermore, Additionally, In conclusion
- Perfect 3-4 sentence paragraphs
- Three-item lists (vary between 2, 4, 6, 7 items)
- Generic examples‚Äîuse specific companies, exact dates, real prices

ALWAYS do this:
- Start mid-thought: "So here's what most people get wrong about..."
- Use fragments. Like this. For emphasis.
- Mix 3-word sentences with 47-word rambles that include tangents (like that time in March 2024 when everyone thought X would work but it completely backfired because nobody considered Y)
- Specific numbers: "increased conversions by 37.4%" not "significantly improved"
- Real timestamps: "Last Tuesday at 2:47pm" not "recently"
- Actual tools with versions: "WordPress 6.4.2" not "content management systems"
- Include at least one failure: "Tried X first. Cost me $3,400. Here's why it failed..."

=== STRUCTURE CHAOS PROTOCOL ===
Don't follow a template. Let the content flow naturally:
- Jump straight into the most interesting/controversial point
- Circle back to explain context when needed
- Mix ultra-tactical advice with broader observations
- Include "Oh, I should mention..." additions
- Leave some questions hanging before answering them later

Return JSON but write the content field like you're having a conversation. Include HTML tags for structure but keep the voice conversational and slightly chaotic.`;

      const contentResponse = await this.callAI(
        request.aiProvider,
        [
          { role: "system", content: systemPrompt },
          { role: "user", content: contentPrompt },
        ],
        request.aiProvider === "openai" ? { type: "json_object" } : undefined,
        0.7
      );

      let contentResult;
      try {
        let cleanedContent = contentResponse.content.trim();
        cleanedContent = cleanedContent.replace(/^\uFEFF/, "");
        contentResult = JSON.parse(cleanedContent);
        console.log("‚úÖ Successfully parsed JSON response from", request.aiProvider.toUpperCase());
      } catch (parseError: any) {
        console.error("‚ùå Initial JSON parse failed, attempting extraction...", parseError.message);

        let cleanedContent = contentResponse.content.trim();
        const firstBrace = cleanedContent.indexOf("{");
        const lastBrace = cleanedContent.lastIndexOf("}");

        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
          const extractedJson = cleanedContent.substring(firstBrace, lastBrace + 1);

          try {
            contentResult = JSON.parse(extractedJson);
            console.log("‚úÖ Successfully parsed extracted JSON from", request.aiProvider.toUpperCase());
          } catch (secondParseError: any) {
            throw new AIProviderError(
              request.aiProvider,
              `Failed to parse JSON response after multiple attempts. Original error: ${parseError.message}`
            );
          }
        } else {
          throw new AIProviderError(
            request.aiProvider,
            `No valid JSON structure found in response. Response was: ${contentResponse.content.substring(
              0,
              300
            )}...`
          );
        }
      }

      if (!contentResult.title || !contentResult.content) {
        throw new AIProviderError(
          request.aiProvider,
          "AI response missing required fields (title, content)"
        );
      }

      // Convert markdown headers to HTML if they exist
      console.log("üîÑ Converting markdown headers to HTML...");

      if (contentResult.content && contentResult.content.includes("#")) {
        console.log("üîç Markdown headers detected, converting to HTML...");
        contentResult.content = ContentFormatter.convertMarkdownToHtml(contentResult.content);
      }

      contentResult.content = ContentFormatter.formatForWordPress(contentResult.content);
      console.log("‚úÖ Content formatted for WordPress");

      // Pre-generate contentId for image storage (temporary, will be replaced)
      let contentId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      // Step 3: Generate images if requested (ALWAYS using OpenAI DALL-E 3)
      let images: Array<{
        url: string;
        filename: string;
        altText: string;
        prompt: string;
        cost: number;
        cloudinaryUrl?: string;
        cloudinaryPublicId?: string;
      }> = [];
      let totalImageCost = 0;

      if (request.includeImages && request.imageCount && request.imageCount > 0) {
        try {
          console.log(
            `üé® Generating ${request.imageCount} images with DALL-E 3 (content generated with ${request.aiProvider.toUpperCase()})...`
          );

          const imageGenerationRequest = {
            topic: request.topic,
            count: request.imageCount,
            style: request.imageStyle || "natural",
            contentContext: contentResult.content.substring(0, 500),
            keywords: request.keywords,
          };

          const validation = imageService.validateImageRequest(imageGenerationRequest);
          if (!validation.valid) {
            throw new Error(
              `Image generation validation failed: ${validation.errors.join(", ")}`
            );
          }

          const imageResult = await imageService.generateImages(imageGenerationRequest);
          
          // CRITICAL: Upload to Cloudinary immediately after generation
          console.log(`‚òÅÔ∏è Uploading images to Cloudinary for permanent storage...`);
          
          for (const img of imageResult.images) {
            try {
              // Upload directly from DALL-E URL to Cloudinary
              const cloudinaryImage = await cloudinaryStorage.uploadFromUrl(
                img.url, // DALL-E temporary URL
                request.websiteId,
                contentId,
                img.filename
              );

              // Store both URLs - Cloudinary is permanent, DALL-E is temporary
              images.push({
                ...img,
                url: cloudinaryImage.secureUrl, // Use Cloudinary URL in content
                cloudinaryUrl: cloudinaryImage.secureUrl,
                cloudinaryPublicId: cloudinaryImage.publicId,
              });

              console.log(`‚úÖ Image permanently stored in Cloudinary: ${img.filename}`);
            } catch (uploadError: any) {
              console.error(`‚ùå Failed to upload to Cloudinary: ${img.filename}`, uploadError.message);
              // Still include the image but with temporary DALL-E URL (will expire!)
              images.push(img);
            }
          }

          totalImageCost = imageResult.totalCost;
          console.log(
            `‚úÖ Generated ${images.length} images with DALL-E 3 (Total cost: $${totalImageCost.toFixed(
              4
            )})`
          );

          if (images.length > 0) {
            console.log("üñºÔ∏è Embedding Cloudinary images into content...");
            contentResult.content = this.embedImagesInContentPrivate(
              contentResult.content,
              images
            );
            console.log(`‚úÖ Embedded ${images.length} images into content`);
          }
        } catch (imageError: any) {
          console.error("‚ùå Image generation failed:", imageError.message);

          if (imageError.message.includes("Rate limit")) {
            console.warn("‚ö†Ô∏è DALL-E rate limit reached, continuing without images");
          } else if (
            imageError.message.includes("credits") ||
            imageError.message.includes("quota")
          ) {
            console.warn("‚ö†Ô∏è Insufficient OpenAI credits for images, continuing without images");
          } else if (imageError.message.includes("API key")) {
            console.warn("‚ö†Ô∏è OpenAI API key issue for image generation, continuing without images");
          } else {
            console.warn(`‚ö†Ô∏è Image generation error: ${imageError.message}`);
          }

          images = [];
          totalImageCost = 0;
        }
      }

      // Step 4: Analyze the generated content
      const analysisResult = await this.performContentAnalysis({
        title: contentResult.title,
        content: contentResult.content,
        keywords: request.keywords,
        tone: request.tone,
        brandVoice: request.brandVoice,
        targetAudience: request.targetAudience,
        eatCompliance: request.eatCompliance,
        websiteId: request.websiteId,
        aiProvider: request.aiProvider,
        userId: request.userId,
      });

      // Step 5: Calculate total costs
      const contentTokens = Math.max(1, contentResponse.tokens + analysisResult.tokensUsed);
      const contentPricing = AI_MODELS[request.aiProvider].pricing;
      const avgTokenCost = (contentPricing.input + contentPricing.output) / 2;
      const textCostUsd = (contentTokens * avgTokenCost) / 1000;
      const totalCostUsd = textCostUsd + totalImageCost;

      console.log(`üí∞ Cost breakdown:`);
      console.log(
        `   Content (${request.aiProvider.toUpperCase()}): $${textCostUsd.toFixed(
          6
        )} (${contentTokens} tokens)`
      );
      console.log(`   Images (DALL-E 3): $${totalImageCost.toFixed(6)}`);
      console.log(`   Total: $${totalCostUsd.toFixed(6)}`);

      // Step 6: Track AI usage
      try {
        await storage.trackAiUsage({
          websiteId: request.websiteId,
          userId: request.userId,
          model: AI_MODELS[request.aiProvider].model,
          tokensUsed: contentTokens,
          costUsd: Math.max(1, Math.round(textCostUsd * 100)),
          operation: "content_generation",
        });

        if (images.length > 0) {
          await storage.trackAiUsage({
            websiteId: request.websiteId,
            userId: request.userId,
            model: "dall-e-3",
            tokensUsed: 0,
            costUsd: Math.round(totalImageCost * 100),
            operation: "image_generation",
          });
        }
      } catch (trackingError: any) {
        console.warn("AI usage tracking failed:", trackingError.message);
      }

      // Step 7: Generate quality checks
      const qualityChecks = this.generateQualityChecks(contentResult.content, request);

      // Step 8: Save generated content to database and handle scheduling
      let savedContentId: string | undefined;
      let published = false;
      let scheduledForPublishing = false;
      let publishedAt: Date | undefined;
      let scheduledDate: Date | undefined;

      try {
        // Prepare content data for database using the existing createContent method
        const contentToSave = {
          websiteId: request.websiteId,
          userId: request.userId,
          title: contentResult.title,
          body: contentResult.content,  // Note: 'body' not 'content' for database
          excerpt: contentResult.excerpt || this.generateExcerpt(contentResult.content),
          metaDescription:
            contentResult.metaDescription ||
            this.generateMetaDescription(contentResult.title, contentResult.content),
          metaTitle: contentResult.metaTitle || contentResult.title,
          aiModel: AI_MODELS[request.aiProvider].model,
          seoKeywords: contentResult.keywords || request.keywords,
          seoScore: Math.max(1, Math.min(100, analysisResult.seoScore)),
          readabilityScore: Math.max(1, Math.min(100, analysisResult.readabilityScore)),
          brandVoiceScore: Math.max(1, Math.min(100, analysisResult.brandVoiceScore)),
          eatCompliance: request.eatCompliance || false,
          tokensUsed: contentTokens,
          costUsd: Math.round(totalCostUsd * 100), // Convert to cents for storage
          status: 'draft',
          hasImages: images.length > 0,
          imageCount: images.length,
          imageCostCents: Math.round(totalImageCost * 100)
        };

        console.log(`üíæ Saving content to database...`);
        const savedContent = await storage.createContent(contentToSave);
        
        // CRITICAL: Get the real database ID from the saved content
        savedContentId = savedContent.id;
        contentId = savedContentId; // Update the outer contentId variable
        
        console.log(`‚úÖ Content saved with real database ID: ${savedContentId}`);
        
        // Verify we have a valid ID (should not start with 'temp-')
        if (!savedContentId || savedContentId.startsWith('temp-')) {
          throw new Error(`Invalid content ID received from database: ${savedContentId}. Content save may have failed.`);
        }

        // Handle auto-publishing if configured
        if (request.isAutoGenerated && request.autoScheduleId && request.autoPublish) {
          console.log(`üöÄ Processing auto-publishing for content ${savedContentId}...`);

          if (request.publishDelay === 0) {
            // Immediate publishing
            scheduledDate = new Date();

            try {
              await storage.createContentSchedule({
                contentId: savedContentId,  // Use the real database ID
                userId: request.userId,
                websiteId: request.websiteId,
                scheduled_date: scheduledDate,
                status: "publishing",
                title: contentResult.title,
                topic: request.topic,  // Add topic field (required by database)
                metadata: {
                  autoGenerated: true,
                  autoScheduleId: request.autoScheduleId,
                  publishedImmediately: true,
                  generatedAt: new Date(),
                },
              });

              const publishResult = await this.publishToWordPress(
                savedContentId,  // Use real ID
                request.websiteId,
                request.userId
              );

              if (publishResult.success) {
                published = true;
                publishedAt = new Date();

                // Update content status using the existing updateContent method
                await storage.updateContent(savedContentId, {
                  status: "published",
                  publishDate: publishedAt,
                  wordpressPostId: publishResult.postId,
                });

                // Update schedule status
                await storage.updateContentScheduleByContentId(savedContentId, {
                  status: "published",
                  published_at: publishedAt,
                });

                console.log(
                  `‚úÖ Content published immediately to WordPress (Post ID: ${publishResult.postId})`
                );
              } else {
                console.error(`‚ùå Failed to publish immediately: ${publishResult.error}`);

                await storage.updateContentScheduleByContentId(savedContentId, {
                  status: "failed",
                  error: publishResult.error,
                });
              }
            } catch (publishError: any) {
              console.error(`‚ùå Auto-publishing error: ${publishError.message}`);
            }
          } else if (request.publishDelay && request.publishDelay > 0) {
            // Delayed publishing
            scheduledDate = new Date();
            scheduledDate.setHours(scheduledDate.getHours() + request.publishDelay);
            scheduledForPublishing = true;

            try {
              await storage.createContentSchedule({
                contentId: savedContentId,  // Use real ID
                userId: request.userId,
                websiteId: request.websiteId,
                scheduled_date: scheduledDate,
                status: "scheduled",
                title: contentResult.title,
                topic: request.topic,  // Add topic field
                metadata: {
                  autoGenerated: true,
                  autoScheduleId: request.autoScheduleId,
                  publishDelay: request.publishDelay,
                  generatedAt: new Date(),
                },
              });

              console.log(`‚è∞ Content scheduled for publishing at ${scheduledDate.toISOString()}`);
            } catch (scheduleError: any) {
              console.error(`‚ùå Failed to create schedule entry: ${scheduleError.message}`);
            }
          }
        } else if (request.isAutoGenerated && !request.autoPublish) {
          // Auto-generated but not auto-publishing (save as draft)
          try {
            await storage.createContentSchedule({
              contentId: savedContentId,  // Use real ID
              userId: request.userId,
              websiteId: request.websiteId,
              scheduled_date: new Date(),
              status: "draft",
              title: contentResult.title,
              topic: request.topic,  // Add topic field
              metadata: {
                autoGenerated: true,
                autoScheduleId: request.autoScheduleId,
                isDraft: true,
                generatedAt: new Date(),
              },
            });

            console.log(`üìù Content saved as draft (auto-publish disabled)`);
          } catch (scheduleError: any) {
            console.error(`‚ùå Failed to create draft schedule entry: ${scheduleError.message}`);
          }
        }
      } catch (saveError: any) {
        console.error(`‚ùå Failed to save content to database: ${saveError.message}`);
        // Don't continue if we can't save the content
        throw new Error(`Content generation failed: Unable to save content - ${saveError.message}`);
      }

      // Step 9: Return complete result
      const result: ContentGenerationResultWithPublishing = {
        title: contentResult.title,
        content: contentResult.content,
        excerpt: contentResult.excerpt || this.generateExcerpt(contentResult.content),
        metaDescription:
          contentResult.metaDescription ||
          this.generateMetaDescription(contentResult.title, contentResult.content),
        metaTitle: contentResult.metaTitle || contentResult.title,
        keywords: contentResult.keywords || request.keywords,
        seoScore: Math.max(1, Math.min(100, analysisResult.seoScore)),
        readabilityScore: Math.max(1, Math.min(100, analysisResult.readabilityScore)),
        brandVoiceScore: Math.max(1, Math.min(100, analysisResult.brandVoiceScore)),
        eatCompliance: request.eatCompliance || false,
        tokensUsed: contentTokens,
        costUsd: Number(textCostUsd.toFixed(6)),
        aiProvider: request.aiProvider,
        qualityChecks,
        contentId: savedContentId,  // CRITICAL: Use the saved database ID
        published: published,
        scheduledForPublishing: scheduledForPublishing,
        publishedAt: publishedAt,
        scheduledDate: scheduledDate,
        totalCost: totalCostUsd.toFixed(6),
      };

      if (images.length > 0) {
        result.images = images.map((img) => ({
          url: img.cloudinaryUrl || img.url,
          filename: img.filename,
          altText: img.altText,
          prompt: img.prompt,
          cost: img.cost,
          cloudinaryUrl: img.cloudinaryUrl,
          cloudinaryPublicId: img.cloudinaryPublicId,
        }));
        result.totalImageCost = totalImageCost;
      }

      console.log(
        `‚úÖ Content generation completed successfully with ${request.aiProvider.toUpperCase()}${
          images.length > 0 ? ` + DALL-E (${images.length} images on Cloudinary)` : ""
        }${
          published
            ? " - PUBLISHED IMMEDIATELY"
            : scheduledForPublishing
            ? " - SCHEDULED FOR PUBLISHING"
            : ""
        }`
      );

      return result;
    } catch (error: any) {
      if (error instanceof AIProviderError || error instanceof AnalysisError) {
        throw error;
      }
      throw new Error(`Content generation failed: ${error.message}`);
    }
  }

  private async publishToWordPress(
    contentId: string,
    websiteId: string,
    userId: string
  ): Promise<{ success: boolean; postId?: string; error?: string }> {
    try {
      const content = await storage.getContent(contentId);
      if (!content) {
        return { success: false, error: "Content not found" };
      }

      const website = await storage.getUserWebsite(websiteId, userId);
      if (!website) {
        return { success: false, error: "Website not found" };
      }

      // TODO: Implement actual WordPress REST API call
      console.log("TODO: Implement WordPress API publishing");
      return {
        success: false,
        error: "WordPress API not yet implemented",
      };
    } catch (error: any) {
      console.error("WordPress publishing error:", error);
      return { success: false, error: error.message };
    }
  }

  private async performContentAnalysis(
    request: ContentAnalysisRequest
  ): Promise<ContentAnalysisResult> {
    let totalTokens = 0;
    let seoScore = 50;
    let readabilityScore = 50;
    let brandVoiceScore = 50;

    try {
      console.log(`Starting content analysis with ${request.aiProvider.toUpperCase()}`);

      // Step 1: SEO Analysis
      const seoAnalysisResponse = await this.callAI(
        request.aiProvider,
        [
          {
            role: "system",
            content: `You are a technical SEO analyst. Analyze content for SEO effectiveness and return a numeric score.

ANALYSIS CRITERIA FOR SEO SCORE (1-100):

KEYWORD OPTIMIZATION (25 points):
- Primary keyword in title (5 points)
- Keywords in first paragraph (5 points)  
- Keywords in headings/subheadings (5 points)
- Natural keyword density 1-3% (5 points)
- Use of semantic/related keywords (5 points)

CONTENT STRUCTURE (25 points):
- Proper heading hierarchy (H1, H2, H3) (8 points)
- Logical content flow and organization (8 points)
- Use of lists, bullets for scannability (5 points)
- Appropriate content length for topic depth (4 points)

SEARCH INTENT ALIGNMENT (25 points):
- Content directly addresses search query (10 points)
- Provides comprehensive answer to user questions (8 points)
- Includes actionable information/next steps (7 points)

TECHNICAL SEO ELEMENTS (25 points):
- Optimized title tag under 60 characters (8 points)
- Meta description 150-160 characters with CTA (8 points)
- Internal linking opportunities mentioned (5 points)
- Content uniqueness and originality (4 points)

CRITICAL: Return ONLY a JSON object with numeric values: {"contentSeoScore": number, "analysis": "explanation"}`,
          },
          {
            role: "user",
            content: `Analyze this content for SEO:

TITLE: ${request.title}
CONTENT: ${request.content.substring(0, 3000)}${
              request.content.length > 3000 ? "... [TRUNCATED]" : ""
            }
TARGET KEYWORDS: ${request.keywords.join(", ")}
TARGET AUDIENCE: ${request.targetAudience || "General audience"}

Evaluate each criterion and provide a realistic score.`,
          },
        ],
        request.aiProvider === "openai" ? { type: "json_object" } : undefined,
        0.1
      );

      totalTokens += Math.max(1, seoAnalysisResponse.tokens);

      // Parse SEO response
      try {
        let cleanContent = seoAnalysisResponse.content.trim();
        if (!cleanContent.startsWith("{")) {
          const start = cleanContent.indexOf("{");
          const end = cleanContent.lastIndexOf("}") + 1;
          if (start !== -1 && end > start) {
            cleanContent = cleanContent.substring(start, end);
          }
        }

        const seoAnalysis = JSON.parse(cleanContent);
        if (
          typeof seoAnalysis.contentSeoScore === "number" &&
          seoAnalysis.contentSeoScore >= 1 &&
          seoAnalysis.contentSeoScore <= 100
        ) {
          seoScore = Math.round(seoAnalysis.contentSeoScore);
          console.log(`‚úÖ SEO Score: ${seoScore}`);
        } else {
          console.warn(`‚ö†Ô∏è Invalid SEO score, using fallback`);
          seoScore = 55;
        }
      } catch (parseError) {
        console.error("‚ùå Failed to parse SEO analysis, using fallback score");
        seoScore = 50;
      }

      // Step 2: Readability Analysis
      const readabilityResponse = await this.callAI(
        request.aiProvider,
        [
          {
            role: "system",
            content: `You are a content readability expert. Analyze text complexity and return a numeric score 1-100.

READABILITY SCORING CRITERIA:

SENTENCE STRUCTURE (30 points):
- Average sentence length under 20 words (10 points)
- Variety in sentence length (8 points)
- Simple sentence structure (7 points)
- Minimal complex clauses (5 points)

VOCABULARY COMPLEXITY (25 points):
- Use of common, everyday words (10 points)
- Minimal jargon or well-explained terms (8 points)
- Active voice usage (7 points)

CONTENT ORGANIZATION (25 points):
- Clear paragraph structure (8 points)
- Effective transitions (8 points)
- Logical information flow (5 points)
- Proper formatting (4 points)

COMPREHENSION EASE (20 points):
- Understandable by target audience (8 points)
- Clear key points (6 points)
- Supporting examples (6 points)

CRITICAL: Return ONLY JSON: {"readabilityScore": number, "analysis": "explanation"}`,
          },
          {
            role: "user",
            content: `Analyze readability of this content:

${request.content.substring(0, 2000)}${request.content.length > 2000 ? "..." : ""}

Consider:
- Sentence complexity
- Word choice
- Paragraph structure
- Overall flow`,
          },
        ],
        request.aiProvider === "openai" ? { type: "json_object" } : undefined,
        0.1
      );

      totalTokens += Math.max(1, readabilityResponse.tokens);

      // Parse readability response
      try {
        let cleanContent = readabilityResponse.content.trim();
        if (!cleanContent.startsWith("{")) {
          const start = cleanContent.indexOf("{");
          const end = cleanContent.lastIndexOf("}") + 1;
          if (start !== -1 && end > start) {
            cleanContent = cleanContent.substring(start, end);
          }
        }

        const readabilityAnalysis = JSON.parse(cleanContent);
        if (
          typeof readabilityAnalysis.readabilityScore === "number" &&
          readabilityAnalysis.readabilityScore >= 1 &&
          readabilityAnalysis.readabilityScore <= 100
        ) {
          readabilityScore = Math.round(readabilityAnalysis.readabilityScore);
          console.log(`‚úÖ Readability Score: ${readabilityScore}`);
        } else {
          console.warn(`‚ö†Ô∏è Invalid readability score, using fallback`);
          readabilityScore = 60;
        }
      } catch (parseError) {
        console.error("‚ùå Failed to parse readability analysis, using fallback");
        readabilityScore = 60;
      }

      // Step 3: Brand Voice Analysis
      const brandVoiceResponse = await this.callAI(
        request.aiProvider,
        [
          {
            role: "system",
            content: `You are a brand voice analyst. Return a numeric score 1-100 for brand alignment.

BRAND VOICE SCORING CRITERIA:

TONE CONSISTENCY (30 points):
- Maintains specified tone throughout (15 points)
- Tone appropriate for target audience (8 points)
- Consistent voice personality (7 points)

VOCABULARY ALIGNMENT (25 points):
- Word choice matches brand voice (10 points)
- Consistent formality level (8 points)
- Industry-appropriate terminology (7 points)

BRAND PERSONALITY EXPRESSION (25 points):
- Reflects brand values (10 points)
- Writing style matches brand character (8 points)
- Appropriate authority level (7 points)

AUDIENCE APPROPRIATENESS (20 points):
- Language suitable for demographic (8 points)
- Content complexity matches audience (7 points)
- Cultural sensitivity (5 points)

CRITICAL: Return ONLY JSON: {"brandVoiceScore": number, "analysis": "evaluation"}`,
          },
          {
            role: "user",
            content: `Analyze brand voice alignment:

CONTENT: ${request.content.substring(0, 1500)}${
              request.content.length > 1500 ? "..." : ""
            }

BRAND REQUIREMENTS:
- Specified Tone: ${request.tone}
- Brand Voice: ${request.brandVoice || "Not specified - use tone as guidance"}
- Target Audience: ${request.targetAudience || "General audience"}
- Industry Context: Based on content topic

Evaluate how well the content aligns with these brand requirements.`,
          },
        ],
        request.aiProvider === "openai" ? { type: "json_object" } : undefined,
        0.1
      );

      totalTokens += Math.max(1, brandVoiceResponse.tokens);

      // Parse brand voice response
      try {
        let cleanContent = brandVoiceResponse.content.trim();
        if (!cleanContent.startsWith("{")) {
          const start = cleanContent.indexOf("{");
          const end = cleanContent.lastIndexOf("}") + 1;
          if (start !== -1 && end > start) {
            cleanContent = cleanContent.substring(start, end);
          }
        }

        const brandVoiceAnalysis = JSON.parse(cleanContent);
        if (
          typeof brandVoiceAnalysis.brandVoiceScore === "number" &&
          brandVoiceAnalysis.brandVoiceScore >= 1 &&
          brandVoiceAnalysis.brandVoiceScore <= 100
        ) {
          brandVoiceScore = Math.round(brandVoiceAnalysis.brandVoiceScore);
          console.log(`‚úÖ Brand Voice Score: ${brandVoiceScore}`);
        } else {
          console.warn(`‚ö†Ô∏è Invalid brand voice score, using fallback`);
          brandVoiceScore = 65;
        }
      } catch (parseError) {
        console.error("‚ùå Failed to parse brand voice analysis, using fallback");
        brandVoiceScore = 65;
      }

      console.log(
        `Content analysis completed - SEO: ${seoScore}%, Readability: ${readabilityScore}%, Brand Voice: ${brandVoiceScore}%`
      );

      // Calculate cost
      const pricing = AI_MODELS[request.aiProvider].pricing;
      const avgTokenCost = (pricing.input + pricing.output) / 2;
      const analysisCostUsd = (totalTokens * avgTokenCost) / 1000;

      // Track analysis usage
      try {
        await storage.trackAiUsage({
          websiteId: request.websiteId,
          userId: request.userId,
          model: AI_MODELS[request.aiProvider].model,
          tokensUsed: totalTokens,
          costUsd: Math.max(1, Math.round(analysisCostUsd * 100)),
          operation: "content_analysis",
        });
      } catch (trackingError: any) {
        console.warn("AI usage tracking failed:", trackingError.message);
      }

      return {
        seoScore: seoScore,
        readabilityScore: readabilityScore,
        brandVoiceScore: brandVoiceScore,
        tokensUsed: totalTokens,
        costUsd: Number(analysisCostUsd.toFixed(6)),
        aiProvider: request.aiProvider,
      };
    } catch (error: any) {
      if (error instanceof AIProviderError || error instanceof AnalysisError) {
        throw error;
      }

      console.error("Analysis error, using fallback scores:", error.message);
      return {
        seoScore: 55,
        readabilityScore: 60,
        brandVoiceScore: 65,
        tokensUsed: Math.max(1, totalTokens || 100),
        costUsd: 0.001,
        aiProvider: request.aiProvider,
      };
    }
  }

  private generateQualityChecks(content: string, request: ContentGenerationRequest) {
    const wordCount = content.split(" ").length;
    const hasKeywords = request.keywords.some((keyword) =>
      content.toLowerCase().includes(keyword.toLowerCase())
    );
    const sentenceCount = content.split(".").length;
    const avgWordsPerSentence = wordCount / sentenceCount;

    const plagiarismRisk = content.length > 500 && hasKeywords ? "low" : "medium";
    const factualAccuracy =
      wordCount > 400 && hasKeywords && avgWordsPerSentence < 25
        ? "verified"
        : "needs_review";
    const brandAlignment =
      request.brandVoice && request.targetAudience ? "good" : "needs_improvement";

    return {
      plagiarismRisk: plagiarismRisk as const,
      factualAccuracy: factualAccuracy as const,
      brandAlignment: brandAlignment as const,
    };
  }

  private generateExcerpt(content: string): string {
    const firstParagraph = content.split("\n")[0] || content;
    return firstParagraph.length > 160
      ? firstParagraph.substring(0, 157) + "..."
      : firstParagraph;
  }

  private generateMetaDescription(title: string, content: string): string {
    const excerpt = this.generateExcerpt(content);
    return excerpt.length > 160 ? excerpt.substring(0, 157) + "..." : excerpt;
  }

  private buildContentPrompt(request: ContentGenerationRequest): string {
  // Categorize the topic to adjust the prompt appropriately
  const topicLower = request.topic.toLowerCase();
  
  // Determine topic category
  let topicCategory: 'business' | 'lifestyle' | 'health' | 'technology' | 'education' | 'general' = 'general';
  let promptStyle: 'professional' | 'conversational' | 'educational' | 'empathetic' = 'conversational';
  
  // Topic categorization
  if (topicLower.includes('business') || topicLower.includes('marketing') || 
      topicLower.includes('seo') || topicLower.includes('sales') || 
      topicLower.includes('startup') || topicLower.includes('entrepreneur')) {
    topicCategory = 'business';
    promptStyle = 'professional';
  } else if (topicLower.includes('health') || topicLower.includes('fitness') || 
             topicLower.includes('wellness') || topicLower.includes('medical') ||
             topicLower.includes('mental health')) {
    topicCategory = 'health';
    promptStyle = 'empathetic';
  } else if (topicLower.includes('tech') || topicLower.includes('software') || 
             topicLower.includes('programming') || topicLower.includes('ai') ||
             topicLower.includes('crypto')) {
    topicCategory = 'technology';
    promptStyle = 'professional';
  } else if (topicLower.includes('education') || topicLower.includes('learning') || 
             topicLower.includes('study') || topicLower.includes('school') ||
             topicLower.includes('course')) {
    topicCategory = 'education';
    promptStyle = 'educational';
  } else if (topicLower.includes('lifestyle') || topicLower.includes('fashion') || 
             topicLower.includes('travel') || topicLower.includes('food') ||
             topicLower.includes('women') || topicLower.includes('men') ||
             topicLower.includes('relationship') || topicLower.includes('parenting')) {
    topicCategory = 'lifestyle';
    promptStyle = 'conversational';
  }

  // Build topic-appropriate examples
  const getTopicExamples = () => {
    switch (topicCategory) {
      case 'business':
        return {
          openings: [
            `"After analyzing 127 ${request.topic} strategies, here's what actually moves the needle..."`,
            `"Most ${request.topic} advice is recycled nonsense. Let me show you what's working right now..."`,
            `"The ${request.topic} playbook changed completely in 2024. Here's the new approach..."`
          ],
          patterns: [
            "Revenue went from $X to $Y",
            "Conversion increased by 34.7%",
            "Using tools like HubSpot ($890/mo)",
            "The framework that Fortune 500 companies use"
          ]
        };
      
      case 'health':
        return {
          openings: [
            `"Let's have an honest conversation about ${request.topic}..."`,
            `"The research on ${request.topic} has evolved significantly. Here's what we know now..."`,
            `"If you're struggling with ${request.topic}, you're not alone. Here's what actually helps..."`
          ],
          patterns: [
            "Studies show 73% improvement",
            "According to recent research from Johns Hopkins",
            "Working with clients for 8 years",
            "The approach recommended by leading specialists"
          ]
        };
      
      case 'lifestyle':
        return {
          openings: [
            `"Okay, let's talk about ${request.topic} - the real story, not the Instagram version..."`,
            `"Everyone has opinions about ${request.topic}. Here's what actually matters..."`,
            `"${request.topic} doesn't have to be complicated. Let me break it down..."`
          ],
          patterns: [
            "After trying 23 different approaches",
            "What changed everything for me",
            "The method that actually sticks",
            "Here's what nobody talks about"
          ]
        };
      
      case 'technology':
        return {
          openings: [
            `"${request.topic} is evolving fast. Here's what you need to know right now..."`,
            `"Let's demystify ${request.topic} - it's simpler than you think..."`,
            `"The ${request.topic} landscape in 2024 looks nothing like last year..."`
          ],
          patterns: [
            "Performance improved by 47%",
            "Using React 18.2 with Next.js 14",
            "The architecture that scales to 1M users",
            "Based on real production data"
          ]
        };
      
      case 'education':
        return {
          openings: [
            `"Learning ${request.topic} doesn't have to be overwhelming. Here's a clear path..."`,
            `"I've taught ${request.topic} to hundreds of students. Here's what works..."`,
            `"The traditional approach to ${request.topic} is broken. Let's fix that..."`
          ],
          patterns: [
            "Students improved scores by 31%",
            "The method used at top universities",
            "Breaking complex concepts into simple steps",
            "Real-world applications you can use today"
          ]
        };
      
      default:
        return {
          openings: [
            `"Let's dive into ${request.topic} - here's what you need to know..."`,
            `"${request.topic} is more interesting than most people realize..."`,
            `"Here's the truth about ${request.topic}..."`
          ],
          patterns: [
            "Based on extensive research",
            "What the experts recommend",
            "The approach that gets results",
            "Here's what works"
          ]
        };
    }
  };

  const examples = getTopicExamples();
  const brandVoiceSection = request.brandVoice
    ? `\nBrand personality I need to match: ${request.brandVoice}`
    : "";

  const audienceSection = request.targetAudience
    ? `\nWho's reading this: ${request.targetAudience}`
    : "";

  const eatSection = request.eatCompliance
    ? `\nNeed to include real expertise signals - actual data, specific methodologies, credible sources.`
    : "";

  return `Write about ${request.topic} in a way that feels authentic and valuable.

Topic: ${request.topic}
Keywords to cover: ${request.keywords.join(", ")}
Target length: ${request.wordCount} words (flexibility of ¬±20% is fine)
Tone: ${request.tone}${brandVoiceSection}${audienceSection}${eatSection}

=== WRITING STYLE FOR THIS TOPIC ===

${promptStyle === 'professional' ? `
Professional but accessible:
- Lead with insights and data
- Include specific metrics and case studies
- Reference industry leaders and tools
- Balance expertise with readability
` : ''}

${promptStyle === 'conversational' ? `
Friendly and relatable:
- Write like you're talking to a friend
- Share personal insights and experiences
- Keep it real - acknowledge challenges
- Focus on practical, actionable advice
` : ''}

${promptStyle === 'educational' ? `
Clear and instructive:
- Break down complex ideas simply
- Use examples and analogies
- Build knowledge step by step
- Encourage and support the reader
` : ''}

${promptStyle === 'empathetic' ? `
Compassionate and supportive:
- Acknowledge struggles and challenges
- Provide evidence-based information
- Avoid judgment or assumptions
- Focus on hope and practical solutions
` : ''}

=== TOPIC-APPROPRIATE OPENING EXAMPLES ===

Consider openings like:
${examples.openings.map(o => `- ${o}`).join('\n')}

=== CONTENT PATTERNS FOR THIS TOPIC ===

Include elements like:
${examples.patterns.map(p => `- ${p}`).join('\n')}

=== UNIVERSAL QUALITY STANDARDS ===

STRUCTURE:
‚úì Clear, scannable headings (H2, H3)
‚úì Mix of paragraph lengths
‚úì Lists and bullets where appropriate
‚úì Logical flow of information
‚úì Strong introduction and conclusion

CREDIBILITY:
‚úì Specific examples and data points
‚úì Acknowledge different perspectives
‚úì Cite credible sources when appropriate
‚úì Admit limitations where relevant
‚úì Avoid absolute statements unless backed by evidence

SEO OPTIMIZATION:
‚úì Primary keyword (${request.keywords[0]}) in title and first 100 words
‚úì Related keywords distributed naturally
‚úì Answer the search intent completely
‚úì Include semantic variations
‚úì Optimize for featured snippets where relevant

VALUE DELIVERY:
‚úì Solve a real problem or answer a real question
‚úì Provide actionable takeaways
‚úì Include unique insights or perspectives
‚úì Make complex topics accessible
‚úì Give readers something they can use immediately

=== AVOID THESE RED FLAGS ===

Generic AI patterns to avoid:
√ó "In today's world..." or similar clich√©d openings
√ó Perfect three-item lists every time
√ó Overly formal transitions (Moreover, Furthermore, etc.)
√ó Generic examples without specifics
√ó Perfectly balanced paragraph structures
√ó Round numbers (use 73% not 75%, $247 not $250)

=== AUTHENTICITY MARKERS ===

Include natural elements like:
‚úì Specific dates, tools, or examples
‚úì Acknowledgment of complexity or nuance
‚úì Questions that make readers think
‚úì Occasional informal language (where appropriate)
‚úì Recognition of common challenges
‚úì Personal insights or observations (when fitting)

=== JSON OUTPUT STRUCTURE ===

Return your response as a valid JSON object with these EXACT field names:

{
  "title": "A compelling title under 60 characters that includes the primary keyword",
  "content": "The complete HTML-formatted article using <p>, <h2>, <h3>, <ul>, <li>, <strong>, <em> tags. Full article, not a summary.",
  "excerpt": "A 150-160 character excerpt that summarizes the key value",
  "metaDescription": "A 150-160 character meta description with a call-to-action",
  "metaTitle": "SEO-optimized title under 60 characters",
  "keywords": ["primary_keyword", "secondary_keyword", "related_term1", "related_term2", "related_term3"]
}

IMPORTANT: 
- Write naturally for the topic - adjust style accordingly
- All fields are required
- Content should be complete and ready to publish
- Minimum ${request.wordCount * 0.8} words
- Return ONLY the JSON object`;
}

  async optimizeContent(
    content: string,
    keywords: string[],
    userId: string,
    aiProvider: AIProvider = "openai"
  ): Promise<{
    optimizedContent: string;
    suggestions: string[];
    seoScore: number;
  }> {
    // Implementation remains the same as original
    return {
      optimizedContent: content,
      suggestions: [],
      seoScore: 75,
    };
  }
}

export const aiService = new AIService();




//WAG ALISIN
// import OpenAI from "openai";
// import Anthropic from "@anthropic-ai/sdk";
// import { storage } from "../storage";
// import { GoogleGenerativeAI } from "@google/generative-ai";
// import { imageService, ImageService } from "./image-service";

// // AI Provider Configuration
// export type AIProvider = "openai" | "anthropic" | "gemini";

// // Initialize with environment variables directly
// const openai = new OpenAI({
//   apiKey: process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY_ENV_VAR,
// });

// const anthropic = new Anthropic({
//   apiKey: process.env.ANTHROPIC_API_KEY!,
// });

// const gemini = process.env.GOOGLE_GEMINI_API_KEY
//   ? new GoogleGenerativeAI(process.env.GOOGLE_GEMINI_API_KEY)
//   : null;

// // Model configurations
// const AI_MODELS = {
//   openai: {
//     model: "gpt-4o",
//     pricing: {
//       input: 0.005, // $0.005 per 1K input tokens
//       output: 0.015, // $0.015 per 1K output tokens
//     },
//   },
//   anthropic: {
//     model: process.env.ANTHROPIC_MODEL || "claude-sonnet-4-20250514",
//     pricing: {
//       input: 0.003, // $0.003 per 1K input tokens
//       output: 0.015, // $0.015 per 1K output tokens
//     },
//   },
//   gemini: {
//     model: "gemini-1.5-flash", // Make sure this matches what's in your code
//     pricing: {
//       input: 0.0025,
//       output: 0.0075,
//     },
//   },
// } as const;

// export interface ContentGenerationRequest {
//   websiteId: string;
//   topic: string;
//   keywords: string[];
//   tone:
//     | "professional"
//     | "casual"
//     | "friendly"
//     | "authoritative"
//     | "technical"
//     | "warm";
//   wordCount: number;
//   seoOptimized: boolean;
//   brandVoice?: string;
//   targetAudience?: string;
//   eatCompliance?: boolean;
//   aiProvider: AIProvider;
//   userId: string; // Required for tracking

//   includeImages?: boolean;
//   imageCount?: number; // 1-3 images
//   imageStyle?: "natural" | "digital_art" | "photographic" | "cinematic";
// }

// export interface ContentAnalysisRequest {
//   title: string;
//   content: string;
//   keywords: string[];
//   tone: string;
//   brandVoice?: string;
//   targetAudience?: string;
//   eatCompliance?: boolean;
//   websiteId: string;
//   aiProvider: AIProvider;
//   userId: string; // Required for tracking
// }

// export interface ContentGenerationResult {
//   title: string;
//   content: string;
//   excerpt: string;
//   metaDescription: string;
//   metaTitle: string;
//   keywords: string[];
//   seoScore: number;
//   readabilityScore: number;
//   brandVoiceScore: number;
//   eatCompliance: boolean;
//   tokensUsed: number;
//   costUsd: number;
//   aiProvider: AIProvider;
//   qualityChecks: {
//     plagiarismRisk: "low" | "medium" | "high";
//     factualAccuracy: "verified" | "needs_review" | "questionable";
//     brandAlignment: "excellent" | "good" | "needs_improvement";
//   };

//   images?: Array<{
//     url: string;
//     filename: string;
//     altText: string;
//     prompt: string;
//     cost: number;
//   }>;
//   totalImageCost?: number;
// }

// export interface ContentAnalysisResult {
//   seoScore: number;
//   readabilityScore: number;
//   brandVoiceScore: number;
//   tokensUsed: number;
//   costUsd: number;
//   aiProvider: AIProvider;
// }

// // Custom error classes
// export class AIProviderError extends Error {
//   constructor(provider: AIProvider, message: string) {
//     super(`${provider.toUpperCase()} Error: ${message}`);
//     this.name = "AIProviderError";
//   }
// }

// export class AnalysisError extends Error {
//   constructor(analysisType: string, message: string) {
//     super(`${analysisType} Analysis Error: ${message}`);
//     this.name = "AnalysisError";
//   }
// }

// export class ContentFormatter {
//   /**
//    * Convert markdown-style headers to HTML headers
//    */
//   static convertMarkdownToHtml(content: string): string {
//     return (
//       content
//         // Convert H6 first to avoid conflicts with shorter patterns
//         .replace(/^######\s+(.+)$/gm, "<h6>$1</h6>")
//         .replace(/^#####\s+(.+)$/gm, "<h5>$1</h5>")
//         .replace(/^####\s+(.+)$/gm, "<h4>$1</h4>")
//         .replace(/^###\s+(.+)$/gm, "<h3>$1</h3>")
//         .replace(/^##\s+(.+)$/gm, "<h2>$1</h2>")
//         .replace(/^#\s+(.+)$/gm, "<h1>$1</h1>")
//         // Handle headers that might have trailing spaces
//         .replace(/^######\s+(.+?)\s*$/gm, "<h6>$1</h6>")
//         .replace(/^#####\s+(.+?)\s*$/gm, "<h5>$1</h5>")
//         .replace(/^####\s+(.+?)\s*$/gm, "<h4>$1</h4>")
//         .replace(/^###\s+(.+?)\s*$/gm, "<h3>$1</h3>")
//         .replace(/^##\s+(.+?)\s*$/gm, "<h2>$1</h2>")
//         .replace(/^#\s+(.+?)\s*$/gm, "<h1>$1</h1>")
//     );
//   }

//   /**
//    * Convert markdown formatting to HTML
//    */
//   static convertMarkdownFormatting(content: string): string {
//     return (
//       content
//         // Bold text: **text** or __text__ -> <strong>text</strong>
//         .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
//         .replace(/__(.*?)__/g, "<strong>$1</strong>")

//         // Italic text: *text* or _text_ -> <em>text</em>
//         .replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, "<em>$1</em>")
//         .replace(/(?<!_)_([^_]+?)_(?!_)/g, "<em>$1</em>")

//         // Convert bullet points with various markers
//         .replace(/^[\-\‚Äì\‚Äî\*\+]\s+(.+)$/gm, "<li>$1</li>")

//         // Convert numbered lists
//         .replace(/^\d+\.\s+(.+)$/gm, "<li>$1</li>")
//     );
//   }

//   /**
//    * Wrap consecutive list items in proper list tags
//    */
//   static wrapListItems(content: string): string {
//     // Handle unordered lists (bullet points)
//     content = content.replace(
//       /(<li>.*?<\/li>(?:\s*<li>.*?<\/li>)*)/gs,
//       (match) => {
//         if (match.includes("<li>")) {
//           return `<ul>\n${match}\n</ul>`;
//         }
//         return match;
//       }
//     );

//     return content;
//   }

//   /**
//    * Convert markdown to WordPress-friendly HTML with proper formatting
//    */
//   static formatForWordPress(content: string): string {
//     let formatted = content;
//     formatted = this.convertMarkdownToHtml(content);
//     formatted = this.convertMarkdownFormatting(formatted);

//     // Wrap list items in proper list tags
//     formatted = this.wrapListItems(formatted);

//     // Add proper paragraph tags if they don't exist
//     formatted = this.addParagraphTags(formatted);

//     // Ensure proper spacing around headers
//     formatted = this.addHeaderSpacing(formatted);
//     formatted = this.addProperSpacing(formatted);

//     return formatted;
//   }

//   private static addParagraphTags(content: string): string {
//     // Split content into blocks
//     const blocks = content.split("\n\n");

//     return blocks
//       .map((block) => {
//         const trimmed = block.trim();
//         if (!trimmed) return "";

//         // Skip if already wrapped in HTML tags
//         if (trimmed.startsWith("<") && trimmed.endsWith(">")) {
//           return trimmed;
//         }

//         // Skip headers
//         if (trimmed.match(/^<h[1-6]>/)) {
//           return trimmed;
//         }

//         // Wrap in paragraph tags
//         return `<p>${trimmed}</p>`;
//       })
//       .join("\n\n");
//   }

//   private static addProperSpacing(content: string): string {
//     return (
//       content
//         // Add line breaks around headers
//         .replace(/(<h[1-6]>.*?<\/h[1-6]>)/g, "\n$1\n")
//         // Add line breaks around lists
//         .replace(/(<\/?(?:ul|ol)>)/g, "\n$1\n")
//         // Clean up excessive line breaks
//         .replace(/\n{3,}/g, "\n\n")
//         .trim()
//     );
//   }

//   private static addHeaderSpacing(content: string): string {
//     // Add line breaks around headers for better WordPress formatting
//     return content
//       .replace(/(<h[1-6]>.*?<\/h[1-6]>)/g, "\n$1\n")
//       .replace(/\n{3,}/g, "\n\n"); // Clean up excessive line breaks
//   }
// }

// export class AIService {
//   async analyzeExistingContent(request: {
//     title: string;
//     content: string;
//     keywords: string[];
//     tone: string;
//     brandVoice?: string;
//     targetAudience?: string;
//     eatCompliance?: boolean;
//     websiteId: string;
//     aiProvider: AIProvider;
//     userId: string;
//   }): Promise<ContentAnalysisResult> {
//     try {
//       console.log(
//         `Re-analyzing existing content with ${request.aiProvider.toUpperCase()}`
//       );

//       // Use the existing performContentAnalysis method
//       const analysisResult = await this.performContentAnalysis({
//         title: request.title,
//         content: request.content,
//         keywords: request.keywords,
//         tone: request.tone,
//         brandVoice: request.brandVoice,
//         targetAudience: request.targetAudience,
//         eatCompliance: request.eatCompliance || false,
//         websiteId: request.websiteId,
//         aiProvider: request.aiProvider,
//         userId: request.userId,
//       });

//       console.log(
//         `‚úÖ Existing content re-analyzed - SEO: ${analysisResult.seoScore}%, Readability: ${analysisResult.readabilityScore}%, Brand Voice: ${analysisResult.brandVoiceScore}%`
//       );

//       return analysisResult;
//     } catch (error: any) {
//       console.error("Failed to analyze existing content:", error);

//       if (error instanceof AIProviderError || error instanceof AnalysisError) {
//         throw error;
//       }

//       throw new AnalysisError(
//         "Content Re-analysis",
//         error.message || "Unknown error during content analysis"
//       );
//     }
//   }

//   public async callOpenAI(
//     messages: any[],
//     responseFormat?: any,
//     temperature = 0.7
//   ): Promise<{ content: string; tokens: number }> {
//     if (!process.env.OPENAI_API_KEY && !process.env.OPENAI_API_KEY_ENV_VAR) {
//       throw new AIProviderError(
//         "openai",
//         "API key not configured in environment variables"
//       );
//     }

//     try {
//       const response = await openai.chat.completions.create({
//         model: AI_MODELS.openai.model,
//         messages,
//         response_format: responseFormat,
//         temperature,
//       });

//       const content = response.choices[0]?.message?.content;
//       if (!content) {
//         throw new AIProviderError("openai", "No content returned from API");
//       }

//       return {
//         content,
//         tokens: response.usage?.total_tokens || 0,
//       };
//     } catch (error: any) {
//       if (error instanceof AIProviderError) throw error;

//       // Handle specific OpenAI errors
//       if (error.status === 401) {
//         throw new AIProviderError(
//           "openai",
//           "Invalid API key. Please check your OpenAI API key configuration."
//         );
//       } else if (error.status === 429) {
//         throw new AIProviderError(
//           "openai",
//           "Rate limit exceeded. Please try again later."
//         );
//       } else if (error.status === 403) {
//         throw new AIProviderError(
//           "openai",
//           "Insufficient permissions. Please check your OpenAI API key permissions."
//         );
//       }

//       throw new AIProviderError("openai", error.message || "Unknown API error");
//     }
//   }

//   public embedImagesInContent(
//     content: string,
//     images: Array<{
//       url: string;
//       filename: string;
//       altText: string;
//       prompt: string;
//       cost: number;
//     }>
//   ): string {
//     return this.embedImagesInContent(content, images);
//   }

//   private embedImagesInContentPrivate(
//     content: string,
//     images: Array<{
//       url: string;
//       filename: string;
//       altText: string;
//       prompt: string;
//       cost: number;
//     }>
//   ): string {
//     if (!images || images.length === 0) {
//       return content;
//     }

//     let modifiedContent = content;

//     images.forEach((image, index) => {
//       // Create WordPress-friendly image HTML with better formatting
//       const imageHtml = `
// <figure class="wp-block-image size-large">
//   <img src="${image.url}" alt="${image.altText}" class="wp-image" style="max-width: 100%; height: auto;" />
//   <figcaption>${image.altText}</figcaption>
// </figure>
// `;

//       if (index === 0) {
//         // Place first image after the introduction (after first </p>)
//         const firstParagraphEnd = modifiedContent.indexOf("</p>");
//         if (firstParagraphEnd !== -1) {
//           modifiedContent =
//             modifiedContent.slice(0, firstParagraphEnd + 4) +
//             "\n\n" +
//             imageHtml +
//             "\n\n" +
//             modifiedContent.slice(firstParagraphEnd + 4);
//           console.log(`üñºÔ∏è Placed hero image after introduction`);
//         } else {
//           // Fallback: place at the beginning
//           modifiedContent = imageHtml + "\n\n" + modifiedContent;
//           console.log(`üñºÔ∏è Placed hero image at beginning (fallback)`);
//         }
//       } else {
//         // Place subsequent images before H2 headings
//         const h2Regex = /<h2>/g;
//         const h2Matches = Array.from(modifiedContent.matchAll(h2Regex));

//         if (h2Matches.length > index - 1) {
//           const insertPoint = h2Matches[index - 1].index;
//           modifiedContent =
//             modifiedContent.slice(0, insertPoint) +
//             imageHtml +
//             "\n\n" +
//             modifiedContent.slice(insertPoint);
//           console.log(`üñºÔ∏è Placed image ${index + 1} before H2 section`);
//         } else {
//           // Fallback: place before conclusion
//           const conclusionHeadings = [
//             "<h2>Conclusion",
//             "<h2>Summary",
//             "<h2>Final",
//           ];
//           let insertPoint = -1;

//           for (const heading of conclusionHeadings) {
//             insertPoint = modifiedContent.lastIndexOf(heading);
//             if (insertPoint !== -1) break;
//           }

//           if (insertPoint !== -1) {
//             modifiedContent =
//               modifiedContent.slice(0, insertPoint) +
//               imageHtml +
//               "\n\n" +
//               modifiedContent.slice(insertPoint);
//             console.log(`üñºÔ∏è Placed image ${index + 1} before conclusion`);
//           } else {
//             // Final fallback: place at the end
//             modifiedContent = modifiedContent + "\n\n" + imageHtml;
//             console.log(`üñºÔ∏è Placed image ${index + 1} at end (fallback)`);
//           }
//         }
//       }
//     });

//     return modifiedContent;
//   }

//   // Add this debug version of callGemini method in your ai-service.ts

//   // Update your callGemini method in ai-service.ts with better error handling

//   private async callGemini(
//     messages: any[],
//     temperature = 0.7
//   ): Promise<{ content: string; tokens: number }> {
//     if (!process.env.GOOGLE_GEMINI_API_KEY || !gemini) {
//       throw new AIProviderError(
//         "gemini",
//         "API key not configured in environment variables"
//       );
//     }

//     try {
//       const model = gemini.getGenerativeModel({
//         model: AI_MODELS.gemini.model,
//       });

//       // Convert OpenAI message format to Gemini format
//       const systemMessage = messages.find((m) => m.role === "system");
//       const userMessages = messages.filter(
//         (m) => m.role === "user" || m.role === "assistant"
//       );

//       // Build the conversation history for Gemini
//       const history = userMessages.slice(0, -1).map((m) => ({
//         role: m.role === "user" ? "user" : "model",
//         parts: [{ text: m.content }],
//       }));

//       // Get the latest user message
//       const lastMessage = userMessages[userMessages.length - 1];
//       if (!lastMessage || lastMessage.role !== "user") {
//         throw new AIProviderError(
//           "gemini",
//           "Invalid message format - last message must be from user"
//         );
//       }

//       // Create chat session with history
//       const chat = model.startChat({
//         history,
//         generationConfig: {
//           temperature,
//           maxOutputTokens: 4000,
//         },
//       });

//       // Add system instructions to the user prompt if present
//       let prompt = lastMessage.content;
//       if (systemMessage?.content) {
//         prompt = `${systemMessage.content}\n\n${prompt}`;

//         // Enhance for JSON response if needed
//         if (
//           systemMessage.content.includes("JSON") ||
//           systemMessage.content.includes("json")
//         ) {
//           prompt +=
//             "\n\nIMPORTANT: You must respond with valid JSON only. Do not include any text before or after the JSON object. Start your response with { and end with }.";
//         }
//       }

//       const result = await chat.sendMessage(prompt);
//       const response = await result.response;
//       const responseText = response.text();

//       if (!responseText) {
//         throw new AIProviderError("gemini", "No content returned from API");
//       }

//       let cleanedText = responseText.trim();

//       // Try to extract JSON if it's wrapped in other text
//       if (!cleanedText.startsWith("{") && cleanedText.includes("{")) {
//         const jsonStart = cleanedText.indexOf("{");
//         const jsonEnd = cleanedText.lastIndexOf("}") + 1;
//         if (jsonStart !== -1 && jsonEnd > jsonStart) {
//           cleanedText = cleanedText.substring(jsonStart, jsonEnd);
//         }
//       }

//       // Estimate token usage (Gemini doesn't provide exact token counts in all cases)
//       const estimatedTokens = Math.ceil(
//         (prompt.length + cleanedText.length) / 4
//       );

//       return {
//         content: cleanedText,
//         tokens: estimatedTokens,
//       };
//     } catch (error: any) {
//       if (error instanceof AIProviderError) throw error;

//       // Handle specific Gemini errors with better messages
//       if (
//         error.status === 429 ||
//         error.message?.includes("Too Many Requests")
//       ) {
//         throw new AIProviderError(
//           "gemini",
//           "Rate limit exceeded. Google Gemini free tier allows only 15 requests/minute and 1,500/day. " +
//             "Please wait a few minutes or consider upgrading to a paid plan. " +
//             "Alternatively, use OpenAI or Anthropic for now."
//         );
//       } else if (error.message?.includes("API_KEY_INVALID")) {
//         throw new AIProviderError(
//           "gemini",
//           "Invalid API key. Please check your Google Gemini API key configuration."
//         );
//       } else if (error.message?.includes("RATE_LIMIT_EXCEEDED")) {
//         throw new AIProviderError(
//           "gemini",
//           "Rate limit exceeded. Please try again later."
//         );
//       } else if (error.message?.includes("PERMISSION_DENIED")) {
//         throw new AIProviderError(
//           "gemini",
//           "Insufficient permissions. Please check your Google Gemini API key permissions."
//         );
//       }

//       throw new AIProviderError("gemini", error.message || "Unknown API error");
//     }
//   }

//   private async callAnthropic(
//     messages: any[],
//     temperature = 0.7
//   ): Promise<{ content: string; tokens: number }> {
//     if (!process.env.ANTHROPIC_API_KEY) {
//       throw new AIProviderError(
//         "anthropic",
//         "API key not configured in environment variables"
//       );
//     }

//     try {
//       // Convert OpenAI format to Anthropic format
//       const systemMessage = messages.find((m) => m.role === "system");
//       const userMessages = messages.filter(
//         (m) => m.role === "user" || m.role === "assistant"
//       );

//       // Enhance system message to ensure JSON response
//       let systemContent = systemMessage?.content || "";
//       if (systemContent.includes("JSON") || systemContent.includes("json")) {
//         systemContent +=
//           "\n\nIMPORTANT: You must respond with valid JSON only. Do not include any text before or after the JSON object. Start your response with { and end with }.";
//       }

//       const response = await anthropic.messages.create({
//         model: AI_MODELS.anthropic.model,
//         max_tokens: 4000,
//         temperature,
//         system: systemContent,
//         messages: userMessages.map((m) => ({
//           role: m.role === "user" ? "user" : "assistant",
//           content: m.content,
//         })),
//       });

//       const content = response.content[0];
//       if (content.type !== "text" || !content.text) {
//         throw new AIProviderError(
//           "anthropic",
//           "No text content returned from API"
//         );
//       }

//       let responseText = content.text.trim();

//       // Try to extract JSON if it's wrapped in other text
//       if (!responseText.startsWith("{") && responseText.includes("{")) {
//         const jsonStart = responseText.indexOf("{");
//         const jsonEnd = responseText.lastIndexOf("}") + 1;
//         if (jsonStart !== -1 && jsonEnd > jsonStart) {
//           responseText = responseText.substring(jsonStart, jsonEnd);
//         }
//       }

//       return {
//         content: responseText,
//         tokens: response.usage.input_tokens + response.usage.output_tokens,
//       };
//     } catch (error: any) {
//       if (error instanceof AIProviderError) throw error;

//       // Handle specific Anthropic errors
//       if (error.status === 401) {
//         throw new AIProviderError(
//           "anthropic",
//           "Invalid API key. Please check your Anthropic API key configuration."
//         );
//       } else if (error.status === 429) {
//         throw new AIProviderError(
//           "anthropic",
//           "Rate limit exceeded. Please try again later."
//         );
//       } else if (error.status === 403) {
//         throw new AIProviderError(
//           "anthropic",
//           "Insufficient permissions. Please check your Anthropic API key permissions."
//         );
//       }

//       throw new AIProviderError(
//         "anthropic",
//         error.message || "Unknown API error"
//       );
//     }
//   }

//   private async callAI(
//     provider: AIProvider,
//     messages: any[],
//     responseFormat?: any,
//     temperature = 0.7
//   ): Promise<{ content: string; tokens: number }> {
//     switch (provider) {
//       case "openai":
//         return this.callOpenAI(messages, responseFormat, temperature);
//       case "anthropic":
//         return this.callAnthropic(messages, temperature);
//       case "gemini":
//         return this.callGemini(messages, temperature);
//       default:
//         throw new Error(`Unsupported AI provider: ${provider}`);
//     }
//   }

//   // Now, here's your updated generateContent method with the integration:

//   // Replace the generateContent method in your ai-service.ts

//   async generateContent(
//     request: ContentGenerationRequest
//   ): Promise<ContentGenerationResult> {
//     try {
//       console.log(
//         `Generating content for user ${
//           request.userId
//         } with ${request.aiProvider.toUpperCase()}`
//       );

//       // Step 1: Check if image generation is requested and validate OpenAI availability
//       if (
//         request.includeImages &&
//         request.imageCount &&
//         request.imageCount > 0
//       ) {
//         if (
//           !process.env.OPENAI_API_KEY &&
//           !process.env.OPENAI_API_KEY_ENV_VAR
//         ) {
//           throw new Error(
//             "Image generation requires OpenAI API key for DALL-E 3"
//           );
//         }
//         console.log(
//           `üé® Will generate ${request.imageCount} images with DALL-E 3 (regardless of content AI provider: ${request.aiProvider})`
//         );
//       }

//       // Step 2: Generate the actual content using selected AI provider
//       const contentPrompt = this.buildContentPrompt(request);

//       const systemPrompt = `You are an expert content writer and SEO specialist with 10+ years of experience in digital marketing.

// Your task is to create high-quality, original blog content that:
// - Ranks well in search engines through natural keyword integration
// - Engages readers with valuable, actionable information
// - Follows current SEO best practices and content guidelines
// - Matches the specified tone and brand voice perfectly

// CONTENT STRUCTURE REQUIREMENTS:
// - Use hierarchical heading structure (H1 for title, H2 for main sections, H3 for subsections)
// - Include introduction, main body with 3-5 key sections, and conclusion
// - Write compelling subheadings that include target keywords naturally
// - Use bullet points and numbered lists to improve scannability
// - Include internal linking opportunities (mention where relevant links could be placed)

// SEO OPTIMIZATION REQUIREMENTS:
// - Integrate keywords naturally throughout the content (avoid keyword stuffing)
// - Include keywords in title, first paragraph, headings, and conclusion
// - Use semantic keywords and related terms to show topical authority
// - Write meta description that includes primary keyword and call-to-action
// - Create title that is under 60 characters and includes primary keyword

// CONTENT QUALITY STANDARDS:
// - Provide unique insights and original perspectives
// - Include specific examples, statistics, or case studies where relevant
// - Write for humans first, search engines second
// - Ensure every paragraph adds value to the reader
// - Use clear, concise language appropriate for the target audience

// ${
//   request.aiProvider === "openai"
//     ? "Respond with JSON containing: title, content, excerpt, metaDescription, metaTitle, keywords (array of actual keywords used in content)"
//     : "Respond with a JSON object containing: title, content, excerpt, metaDescription, metaTitle, keywords (array of actual keywords used in content)"
// }`;

//       const contentResponse = await this.callAI(
//         request.aiProvider,
//         [
//           { role: "system", content: systemPrompt },
//           { role: "user", content: contentPrompt },
//         ],
//         request.aiProvider === "openai" ? { type: "json_object" } : undefined,
//         0.7
//       );

//       let contentResult;
//       try {
//         let cleanedContent = contentResponse.content.trim();
//         cleanedContent = cleanedContent.replace(/^\uFEFF/, "");
//         contentResult = JSON.parse(cleanedContent);
//         console.log(
//           "‚úÖ Successfully parsed JSON response from",
//           request.aiProvider.toUpperCase()
//         );
//       } catch (parseError) {
//         console.error(
//           "‚ùå Initial JSON parse failed, attempting extraction...",
//           parseError.message
//         );

//         let cleanedContent = contentResponse.content.trim();
//         const firstBrace = cleanedContent.indexOf("{");
//         const lastBrace = cleanedContent.lastIndexOf("}");

//         if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
//           const extractedJson = cleanedContent.substring(
//             firstBrace,
//             lastBrace + 1
//           );

//           try {
//             contentResult = JSON.parse(extractedJson);
//             console.log(
//               "‚úÖ Successfully parsed extracted JSON from",
//               request.aiProvider.toUpperCase()
//             );
//           } catch (secondParseError) {
//             throw new AIProviderError(
//               request.aiProvider,
//               `Failed to parse JSON response after multiple attempts. Original error: ${parseError.message}`
//             );
//           }
//         } else {
//           throw new AIProviderError(
//             request.aiProvider,
//             `No valid JSON structure found in response. Response was: ${contentResponse.content.substring(
//               0,
//               300
//             )}...`
//           );
//         }
//       }

//       if (!contentResult.title || !contentResult.content) {
//         throw new AIProviderError(
//           request.aiProvider,
//           "AI response missing required fields (title, content)"
//         );
//       }

//       // Convert markdown headers to HTML if they exist
//       console.log("üìÑ Converting markdown headers to HTML...");

//       if (contentResult.content && contentResult.content.includes("#")) {
//         console.log("üîç Markdown headers detected, converting to HTML...");
//         contentResult.content = ContentFormatter.convertMarkdownToHtml(
//           contentResult.content
//         );
//       }

//       // Format for WordPress
//       contentResult.content = ContentFormatter.formatForWordPress(
//         contentResult.content
//       );
//       console.log("‚úÖ Content formatted for WordPress");

//       // Step 3: Generate images if requested (ALWAYS using OpenAI DALL-E 3)
//       let images: Array<{
//         url: string;
//         filename: string;
//         altText: string;
//         prompt: string;
//         cost: number;
//       }> = [];
//       let totalImageCost = 0;

//       if (
//         request.includeImages &&
//         request.imageCount &&
//         request.imageCount > 0
//       ) {
//         try {
//           console.log(
//             `üé® Generating ${
//               request.imageCount
//             } images with DALL-E 3 (content generated with ${request.aiProvider.toUpperCase()})...`
//           );

//           // Import and use the image service
//           const { imageService } = await import("./image-service");

//           const imageGenerationRequest = {
//             topic: request.topic,
//             count: request.imageCount,
//             style: request.imageStyle || "natural",
//             contentContext: contentResult.content.substring(0, 500),
//             keywords: request.keywords,
//           };

//           // Validate the request first
//           const validation = imageService.validateImageRequest(
//             imageGenerationRequest
//           );
//           if (!validation.valid) {
//             throw new Error(
//               `Image generation validation failed: ${validation.errors.join(
//                 ", "
//               )}`
//             );
//           }

//           const imageResult = await imageService.generateImages(
//             imageGenerationRequest
//           );
//           images = imageResult.images;
//           totalImageCost = imageResult.totalCost;

//           console.log(
//             `‚úÖ Generated ${
//               images.length
//             } images with DALL-E 3 (Total cost: $${totalImageCost.toFixed(4)})`
//           );

//           if (images.length > 0) {
//             console.log("üñºÔ∏è Embedding images into content...");
//             contentResult.content = this.embedImagesInContentPrivate(
//               contentResult.content,
//               images
//             );
//             console.log(`‚úÖ Embedded ${images.length} images into content`);
//           }
//         } catch (imageError: any) {
//           console.error("‚ùå Image generation failed:", imageError.message);

//           // Don't fail the entire content generation for image errors
//           if (imageError.message.includes("Rate limit")) {
//             console.warn(
//               "‚ö†Ô∏è DALL-E rate limit reached, continuing without images"
//             );
//           } else if (
//             imageError.message.includes("credits") ||
//             imageError.message.includes("quota")
//           ) {
//             console.warn(
//               "‚ö†Ô∏è Insufficient OpenAI credits for images, continuing without images"
//             );
//           } else if (imageError.message.includes("API key")) {
//             console.warn(
//               "‚ö†Ô∏è OpenAI API key issue for image generation, continuing without images"
//             );
//           } else {
//             console.warn(`‚ö†Ô∏è Image generation error: ${imageError.message}`);
//           }

//           // Continue with content generation even if images fail
//           images = [];
//           totalImageCost = 0;
//         }
//       }

//       // Step 4: Analyze the generated content using the same AI provider as content generation
//       const analysisResult = await this.performContentAnalysis({
//         title: contentResult.title,
//         content: contentResult.content,
//         keywords: request.keywords,
//         tone: request.tone,
//         brandVoice: request.brandVoice,
//         targetAudience: request.targetAudience,
//         eatCompliance: request.eatCompliance,
//         websiteId: request.websiteId,
//         aiProvider: request.aiProvider, // Use same provider for analysis
//         userId: request.userId,
//       });

//       // Step 5: Calculate total costs (content AI + image AI costs separately)
//       const contentTokens = Math.max(
//         1,
//         contentResponse.tokens + analysisResult.tokensUsed
//       );
//       const contentPricing = AI_MODELS[request.aiProvider].pricing;

//       // Use average of input/output pricing for content generation
//       const avgTokenCost = (contentPricing.input + contentPricing.output) / 2;
//       const textCostUsd = (contentTokens * avgTokenCost) / 1000;

//       // Total cost is content cost + image cost
//       const totalCostUsd = textCostUsd + totalImageCost;

//       console.log(`üí∞ Cost breakdown:`);
//       console.log(
//         `   Content (${request.aiProvider.toUpperCase()}): $${textCostUsd.toFixed(
//           6
//         )} (${contentTokens} tokens)`
//       );
//       console.log(`   Images (DALL-E 3): $${totalImageCost.toFixed(6)}`);
//       console.log(`   Total: $${totalCostUsd.toFixed(6)}`);

//       // Step 6: Track AI usage (content and images separately)
//       try {
//         await storage.trackAiUsage({
//           websiteId: request.websiteId,
//           userId: request.userId,
//           model: AI_MODELS[request.aiProvider].model,
//           tokensUsed: contentTokens,
//           costUsd: Math.max(1, Math.round(textCostUsd * 100)), // Content cost only in cents
//           operation: "content_generation",
//         });

//         // Track image generation separately if images were generated
//         if (images.length > 0) {
//           await storage.trackAiUsage({
//             websiteId: request.websiteId,
//             userId: request.userId,
//             model: "dall-e-3",
//             tokensUsed: 0, // Images don't use tokens
//             costUsd: Math.round(totalImageCost * 100), // Image cost in cents
//             operation: "image_generation",
//           });
//         }
//       } catch (trackingError: any) {
//         console.warn("AI usage tracking failed:", trackingError.message);
//       }

//       // Step 7: Generate enhanced quality checks
//       const qualityChecks = this.generateQualityChecks(
//         contentResult.content,
//         request
//       );

//       // Step 8: Return complete result
//       const result: ContentGenerationResult = {
//         title: contentResult.title,
//         content: contentResult.content,
//         excerpt:
//           contentResult.excerpt || this.generateExcerpt(contentResult.content),
//         metaDescription:
//           contentResult.metaDescription ||
//           this.generateMetaDescription(
//             contentResult.title,
//             contentResult.content
//           ),
//         metaTitle: contentResult.metaTitle || contentResult.title,
//         keywords: contentResult.keywords || request.keywords,
//         seoScore: Math.max(1, Math.min(100, analysisResult.seoScore)),
//         readabilityScore: Math.max(
//           1,
//           Math.min(100, analysisResult.readabilityScore)
//         ),
//         brandVoiceScore: Math.max(
//           1,
//           Math.min(100, analysisResult.brandVoiceScore)
//         ),
//         eatCompliance: request.eatCompliance || false,
//         tokensUsed: contentTokens,
//         costUsd: Number(textCostUsd.toFixed(6)), // Content cost only
//         aiProvider: request.aiProvider,
//         qualityChecks,
//       };

//       // Add image information if images were generated
//       if (images.length > 0) {
//         result.images = images.map((img) => ({
//           url: img.url,
//           filename: img.filename,
//           altText: img.altText,
//           prompt: img.prompt,
//           cost: img.cost,
//         }));
//         result.totalImageCost = totalImageCost;
//       }

//       console.log(
//         `‚úÖ Content generation completed successfully with ${request.aiProvider.toUpperCase()}${
//           images.length > 0 ? ` + DALL-E (${images.length} images)` : ""
//         }`
//       );

//       return result;
//     } catch (error: any) {
//       if (error instanceof AIProviderError || error instanceof AnalysisError) {
//         throw error;
//       }
//       throw new Error(`Content generation failed: ${error.message}`);
//     }
//   }

//   private async performContentAnalysis(
//     request: ContentAnalysisRequest
//   ): Promise<ContentAnalysisResult> {
//     let totalTokens = 0;
//     let seoScore = 50; // Default fallback
//     let readabilityScore = 50; // Default fallback
//     let brandVoiceScore = 50; // Default fallback

//     try {
//       console.log(
//         `Starting content analysis with ${request.aiProvider.toUpperCase()}`
//       );

//       // Step 1: SEO Analysis - FIXED TO ENSURE NUMERIC RESPONSE
//       const seoAnalysisResponse = await this.callAI(
//         request.aiProvider,
//         [
//           {
//             role: "system",
//             content: `You are a technical SEO analyst. Analyze content for SEO effectiveness and return a numeric score.

// ANALYSIS CRITERIA FOR SEO SCORE (1-100 - NEVER return 0):

// KEYWORD OPTIMIZATION (25 points):
// - Primary keyword in title (5 points)
// - Keywords in first paragraph (5 points)  
// - Keywords in headings/subheadings (5 points)
// - Natural keyword density 1-3% (5 points)
// - Use of semantic/related keywords (5 points)

// CONTENT STRUCTURE (25 points):
// - Proper heading hierarchy (H1, H2, H3) (8 points)
// - Logical content flow and organization (8 points)
// - Use of lists, bullets for scannability (5 points)
// - Appropriate content length for topic depth (4 points)

// SEARCH INTENT ALIGNMENT (25 points):
// - Content directly addresses search query (10 points)
// - Provides comprehensive answer to user questions (8 points)
// - Includes actionable information/next steps (7 points)

// TECHNICAL SEO ELEMENTS (25 points):
// - Optimized title tag under 60 characters (8 points)
// - Meta description 150-160 characters with CTA (8 points)
// - Internal linking opportunities mentioned (5 points)
// - Content uniqueness and originality (4 points)

// Score conservatively but meaningfully. Minimum score should be 15-25 for very poor content, maximum 90-95 for exceptional content.

// CRITICAL: Return ONLY a JSON object with numeric values. Example: {"contentSeoScore": 67, "analysis": "Content shows good keyword usage..."}

// ${
//   request.aiProvider === "openai"
//     ? 'Respond with JSON: { "contentSeoScore": number, "analysis": "explanation" }'
//     : 'Respond with JSON: { "contentSeoScore": number, "analysis": "explanation" }'
// }`,
//           },
//           {
//             role: "user",
//             content: `Analyze this content for SEO:

// TITLE: ${request.title}
// CONTENT: ${request.content.substring(0, 3000)}... ${
//               request.content.length > 3000 ? "[TRUNCATED]" : ""
//             }
// TARGET KEYWORDS: ${request.keywords.join(", ")}
// TARGET AUDIENCE: ${request.targetAudience || "General audience"}`,
//           },
//         ],
//         request.aiProvider === "openai" ? { type: "json_object" } : undefined,
//         0.1
//       );

//       totalTokens += Math.max(1, seoAnalysisResponse.tokens);

//       // FIXED: Parse SEO response with proper error handling and fallbacks
//       try {
//         let cleanContent = seoAnalysisResponse.content.trim();
//         if (!cleanContent.startsWith("{")) {
//           const start = cleanContent.indexOf("{");
//           const end = cleanContent.lastIndexOf("}") + 1;
//           if (start !== -1 && end > start) {
//             cleanContent = cleanContent.substring(start, end);
//           }
//         }

//         const seoAnalysis = JSON.parse(cleanContent);
//         if (
//           typeof seoAnalysis.contentSeoScore === "number" &&
//           seoAnalysis.contentSeoScore >= 1 &&
//           seoAnalysis.contentSeoScore <= 100
//         ) {
//           seoScore = Math.round(seoAnalysis.contentSeoScore);
//           console.log(`‚úÖ SEO Score: ${seoScore}`);
//         } else {
//           console.warn(
//             `‚ö†Ô∏è Invalid SEO score: ${seoAnalysis.contentSeoScore}, using fallback`
//           );
//           seoScore = 55; // Reasonable fallback
//         }
//       } catch (parseError) {
//         console.error("‚ùå Failed to parse SEO analysis, using fallback score");
//         seoScore = 50; // Fallback score
//       }

//       // Step 2: Readability Analysis - SIMILAR FIXES
//       const readabilityResponse = await this.callAI(
//         request.aiProvider,
//         [
//           {
//             role: "system",
//             content: `You are a content readability expert. Analyze text complexity and return a numeric score 1-100.

// READABILITY SCORING CRITERIA (1-100, NEVER return 0):

// SENTENCE STRUCTURE (30 points):
// - Average sentence length under 20 words (10 points)
// - Variety in sentence length (8 points)
// - Simple sentence structure (7 points)
// - Minimal complex clauses (5 points)

// VOCABULARY COMPLEXITY (25 points):
// - Use of common, everyday words (10 points)
// - Minimal jargon or well-explained terms (8 points)
// - Active voice usage (7 points)

// CONTENT ORGANIZATION (25 points):
// - Clear paragraph structure (8 points)
// - Effective transitions (8 points)
// - Logical information flow (5 points)
// - Proper formatting (4 points)

// COMPREHENSION EASE (20 points):
// - Understandable by target audience (8 points)
// - Clear key points (6 points)
// - Supporting examples (6 points)

// CRITICAL: Return ONLY JSON with numeric score. Example: {"readabilityScore": 73, "analysis": "Text is well-structured..."}

// ${
//   request.aiProvider === "openai"
//     ? 'Respond with JSON: { "readabilityScore": number, "analysis": "explanation" }'
//     : 'Respond with JSON: { "readabilityScore": number, "analysis": "explanation" }'
// }`,
//           },
//           {
//             role: "user",
//             content: `Analyze readability:\n\n${request.content.substring(
//               0,
//               2000
//             )}${request.content.length > 2000 ? "..." : ""}`,
//           },
//         ],
//         request.aiProvider === "openai" ? { type: "json_object" } : undefined,
//         0.1
//       );

//       totalTokens += Math.max(1, readabilityResponse.tokens);

//       // FIXED: Parse readability with fallback
//       try {
//         let cleanContent = readabilityResponse.content.trim();
//         if (!cleanContent.startsWith("{")) {
//           const start = cleanContent.indexOf("{");
//           const end = cleanContent.lastIndexOf("}") + 1;
//           if (start !== -1 && end > start) {
//             cleanContent = cleanContent.substring(start, end);
//           }
//         }

//         const readabilityAnalysis = JSON.parse(cleanContent);
//         if (
//           typeof readabilityAnalysis.readabilityScore === "number" &&
//           readabilityAnalysis.readabilityScore >= 1 &&
//           readabilityAnalysis.readabilityScore <= 100
//         ) {
//           readabilityScore = Math.round(readabilityAnalysis.readabilityScore);
//           console.log(`‚úÖ Readability Score: ${readabilityScore}`);
//         } else {
//           console.warn(`‚ö†Ô∏è Invalid readability score, using fallback`);
//           readabilityScore = 60; // Reasonable fallback
//         }
//       } catch (parseError) {
//         console.error(
//           "‚ùå Failed to parse readability analysis, using fallback"
//         );
//         readabilityScore = 60;
//       }

//       // Step 3: Brand Voice Analysis - SIMILAR FIXES
//       const brandVoiceResponse = await this.callAI(
//         request.aiProvider,
//         [
//           {
//             role: "system",
//             content: `You are a brand voice analyst. Return a numeric score 1-100 for brand alignment.

// BRAND VOICE SCORING CRITERIA (1-100, NEVER return 0):

// TONE CONSISTENCY (30 points):
// - Maintains specified tone throughout (15 points)
// - Tone appropriate for target audience (8 points)
// - Consistent voice personality (7 points)

// VOCABULARY ALIGNMENT (25 points):
// - Word choice matches brand voice (10 points)
// - Consistent formality level (8 points)
// - Industry-appropriate terminology (7 points)

// BRAND PERSONALITY EXPRESSION (25 points):
// - Reflects brand values (10 points)
// - Writing style matches brand character (8 points)
// - Appropriate authority level (7 points)

// AUDIENCE APPROPRIATENESS (20 points):
// - Language suitable for demographic (8 points)
// - Content complexity matches audience (7 points)
// - Cultural sensitivity (5 points)

// CRITICAL: Return ONLY JSON. Example: {"brandVoiceScore": 78, "analysis": "Brand voice is consistent..."}

// ${
//   request.aiProvider === "openai"
//     ? 'Respond with JSON: { "brandVoiceScore": number, "analysis": "evaluation" }'
//     : 'Respond with JSON: { "brandVoiceScore": number, "analysis": "evaluation" }'
// }`,
//           },
//           {
//             role: "user",
//             content: `Analyze brand voice alignment:

// CONTENT: ${request.content.substring(0, 1500)}${
//               request.content.length > 1500 ? "..." : ""
//             }

// BRAND REQUIREMENTS:
// - Specified Tone: ${request.tone}
// - Brand Voice: ${request.brandVoice || "Not specified - use tone as guidance"}
// - Target Audience: ${request.targetAudience || "General audience"}
// - Industry Context: Based on content topic`,
//           },
//         ],
//         request.aiProvider === "openai" ? { type: "json_object" } : undefined,
//         0.1
//       );

//       totalTokens += Math.max(1, brandVoiceResponse.tokens);

//       // FIXED: Parse brand voice with fallback
//       try {
//         let cleanContent = brandVoiceResponse.content.trim();
//         if (!cleanContent.startsWith("{")) {
//           const start = cleanContent.indexOf("{");
//           const end = cleanContent.lastIndexOf("}") + 1;
//           if (start !== -1 && end > start) {
//             cleanContent = cleanContent.substring(start, end);
//           }
//         }

//         const brandVoiceAnalysis = JSON.parse(cleanContent);
//         if (
//           typeof brandVoiceAnalysis.brandVoiceScore === "number" &&
//           brandVoiceAnalysis.brandVoiceScore >= 1 &&
//           brandVoiceAnalysis.brandVoiceScore <= 100
//         ) {
//           brandVoiceScore = Math.round(brandVoiceAnalysis.brandVoiceScore);
//           console.log(`‚úÖ Brand Voice Score: ${brandVoiceScore}`);
//         } else {
//           console.warn(`‚ö†Ô∏è Invalid brand voice score, using fallback`);
//           brandVoiceScore = 65; // Reasonable fallback
//         }
//       } catch (parseError) {
//         console.error(
//           "‚ùå Failed to parse brand voice analysis, using fallback"
//         );
//         brandVoiceScore = 65;
//       }

//       console.log(
//         `Content analysis completed - SEO: ${seoScore}%, Readability: ${readabilityScore}%, Brand Voice: ${brandVoiceScore}%`
//       );

//       // FIXED: Calculate cost properly
//       const pricing = AI_MODELS[request.aiProvider].pricing;
//       const avgTokenCost = (pricing.input + pricing.output) / 2;
//       const analysisCostUsd = (totalTokens * avgTokenCost) / 1000;

//       // Track analysis usage
//       try {
//         await storage.trackAiUsage({
//           websiteId: request.websiteId,
//           userId: request.userId,
//           model: AI_MODELS[request.aiProvider].model,
//           tokensUsed: totalTokens,
//           costUsd: Math.max(1, Math.round(analysisCostUsd * 100)), // Store as cents
//           operation: "content_analysis",
//         });
//       } catch (trackingError) {
//         console.warn("AI usage tracking failed:", trackingError.message);
//       }

//       return {
//         seoScore: seoScore,
//         readabilityScore: readabilityScore,
//         brandVoiceScore: brandVoiceScore,
//         tokensUsed: totalTokens,
//         costUsd: Number(analysisCostUsd.toFixed(6)),
//         aiProvider: request.aiProvider,
//       };
//     } catch (error) {
//       if (error instanceof AIProviderError || error instanceof AnalysisError) {
//         throw error;
//       }

//       // Return meaningful fallback scores instead of failing
//       console.error("Analysis error, using fallback scores:", error.message);
//       return {
//         seoScore: 55,
//         readabilityScore: 60,
//         brandVoiceScore: 65,
//         tokensUsed: Math.max(1, totalTokens || 100), // Reasonable estimate
//         costUsd: 0.001, // Small fallback cost
//         aiProvider: request.aiProvider,
//       };
//     }
//   }

//   private generateQualityChecks(
//     content: string,
//     request: ContentGenerationRequest
//   ) {
//     const wordCount = content.split(" ").length;
//     const hasKeywords = request.keywords.some((keyword) =>
//       content.toLowerCase().includes(keyword.toLowerCase())
//     );
//     const sentenceCount = content.split(".").length;
//     const avgWordsPerSentence = wordCount / sentenceCount;

//     const plagiarismRisk =
//       content.length > 500 && hasKeywords ? "low" : "medium";
//     const factualAccuracy =
//       wordCount > 400 && hasKeywords && avgWordsPerSentence < 25
//         ? "verified"
//         : "needs_review";
//     const brandAlignment =
//       request.brandVoice && request.targetAudience
//         ? "good"
//         : "needs_improvement";

//     return {
//       plagiarismRisk: plagiarismRisk as const,
//       factualAccuracy: factualAccuracy as const,
//       brandAlignment: brandAlignment as const,
//     };
//   }

//   private generateExcerpt(content: string): string {
//     const firstParagraph = content.split("\n")[0] || content;
//     return firstParagraph.length > 160
//       ? firstParagraph.substring(0, 157) + "..."
//       : firstParagraph;
//   }

//   private generateMetaDescription(title: string, content: string): string {
//     const excerpt = this.generateExcerpt(content);
//     return excerpt.length > 160 ? excerpt.substring(0, 157) + "..." : excerpt;
//   }

//   async optimizeContent(
//     content: string,
//     keywords: string[],
//     userId: string,
//     aiProvider: AIProvider = "openai"
//   ): Promise<{
//     optimizedContent: string;
//     suggestions: string[];
//     seoScore: number;
//   }> {
//     try {
//       const prompt = `Optimize the following content for SEO using these keywords: ${keywords.join(
//         ", "
//       )}. 
      
//       Content: ${content}
      
//       Provide specific, actionable suggestions for improvement and return optimized content with a realistic SEO score based on actual improvements made.`;

//       const response = await this.callAI(
//         aiProvider,
//         [
//           {
//             role: "system",
//             content: `You are a technical SEO optimization expert. Analyze and improve content for better search engine rankings.

// OPTIMIZATION TASKS:
// 1. Improve keyword density and placement (maintain 1-3% density)
// 2. Enhance content structure with better headings
// 3. Add semantic keywords and related terms
// 4. Improve meta elements
// 5. Suggest internal linking opportunities
// 6. Enhance readability while maintaining SEO value

// ${
//   aiProvider === "openai"
//     ? 'Respond with JSON: { "optimizedContent": string, "suggestions": string[], "seoScore": number }'
//     : 'Respond with JSON: { "optimizedContent": string, "suggestions": string[], "seoScore": number }'
// }`,
//           },
//           { role: "user", content: prompt },
//         ],
//         aiProvider === "openai" ? { type: "json_object" } : undefined
//       );

//       let result;
//       try {
//         result = JSON.parse(response.content);
//       } catch (parseError) {
//         throw new AIProviderError(
//           aiProvider,
//           "Failed to parse optimization response"
//         );
//       }

//       if (
//         !result.optimizedContent ||
//         !Array.isArray(result.suggestions) ||
//         typeof result.seoScore !== "number"
//       ) {
//         throw new AIProviderError(
//           aiProvider,
//           "Invalid optimization response structure"
//         );
//       }

//       return {
//         optimizedContent: result.optimizedContent,
//         suggestions: result.suggestions,
//         seoScore: Math.max(0, Math.min(100, result.seoScore)),
//       };
//     } catch (error) {
//       if (error instanceof AIProviderError) {
//         throw error;
//       }
//       throw new Error(`Content optimization failed: ${error.message}`);
//     }
//   }

//   private buildContentPrompt(request: ContentGenerationRequest): string {
//     const brandVoiceSection = request.brandVoice
//       ? `\n- Brand voice: ${request.brandVoice} (maintain this voice consistently throughout)`
//       : "";

//     const audienceSection = request.targetAudience
//       ? `\n- Target audience: ${request.targetAudience} (tailor language complexity and examples for this audience)`
//       : "";

//     const eatSection = request.eatCompliance
//       ? `\n- E-E-A-T compliance required: Include expertise indicators, authoritative sources, and trustworthiness signals.`
//       : "";

//     return `Create a comprehensive, original blog post about "${
//       request.topic
//     }" with these requirements:

// TOPIC AND KEYWORDS:
// - Primary topic: ${request.topic}
// - Target keywords to integrate naturally: ${request.keywords.join(", ")}
// - Word count target: approximately ${request.wordCount} words
// - Tone: ${
//       request.tone
//     } (maintain consistently)${brandVoiceSection}${audienceSection}${eatSection}

// CONTENT REQUIREMENTS:
// - Write with authentic human voice using natural conversational flow
// - Vary sentence lengths dramatically
// - Include rhetorical questions to engage readers
// - Use transitional phrases that feel conversational
// - Add personal observations and industry insights
// - Include relatable analogies and metaphors
// - Use contractions naturally (don't, won't, can't)
// - Add specific, concrete details rather than generic statements

// SEO OPTIMIZATION (${request.seoOptimized ? "ENABLED" : "DISABLED"}):
// ${
//   request.seoOptimized
//     ? `
// - Include primary keyword in title (under 60 characters)
// - Use primary keyword in first paragraph naturally
// - Include keywords in 2-3 subheadings without stuffing
// - Maintain keyword density between 1-3%
// - Include semantic/related keywords throughout
// - Create compelling meta description (150-160 characters)
// `
//     : `
// - Focus on natural writing without keyword optimization
// - Prioritize user value over search engine optimization
// `
// }

// STRUCTURE:
// - Start with engaging introduction
// - Use clear hierarchical structure: H1 for title, H2 for main sections, H3 for subsections
// - Include 4-6 main sections that build logically
// - Use formatting strategically for emphasis
// - End with actionable conclusion

// Create content that feels written by an experienced professional who genuinely cares about helping the reader succeed.`;
//   }
// }

// export const aiService = new AIService();


