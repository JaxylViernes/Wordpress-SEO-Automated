//server/services/auto-schedule-service.ts
import { storage } from "../storage";
import { aiService } from "./ai-service";
import { schedulerService } from "./scheduler-service";

export class AutoScheduleService {
  private isProcessing = false;

  async processAutoSchedules(): Promise<{
    processed: number;
    generated: number;
    failed: number;
    results: any[];
  }> {
    if (this.isProcessing) {
      console.log("â³ Auto-schedule processor already running...");
      return { processed: 0, generated: 0, failed: 0, results: [] };
    }

    this.isProcessing = true;
    console.log("ðŸ¤– Starting auto-content generation...");

    try {
      const now = new Date();
      const currentHour = now.getHours();
      const currentDay = now.toLocaleDateString("en-US", { weekday: "long" });

      // Get active schedules that should run now
      const schedules = await storage.getActiveAutoSchedules();
      const results = [];

      for (const schedule of schedules) {
        if (!this.shouldRunSchedule(schedule, currentHour, currentDay)) {
          continue;
        }

        // Check daily cost limit
        if (schedule.costToday >= schedule.maxDailyCost) {
          console.log(
            `ðŸ’° Daily cost limit reached for schedule: ${schedule.name}`
          );
          continue;
        }

        // Check monthly post limit
        if (schedule.postsThisMonth >= schedule.maxMonthlyPosts) {
          console.log(
            `ðŸ“Š Monthly post limit reached for schedule: ${schedule.name}`
          );
          continue;
        }

        try {
          console.log(`ðŸš€ Running auto-schedule: ${schedule.name}`);

          // Select topic based on rotation strategy
          const topic = this.selectTopic(schedule);

          // Generate content
          const generationResult = await this.generateContent(schedule, topic);

          if (generationResult.success) {
            //nadagdag - Fixed numeric conversion for cost calculations
            // Update schedule metrics with proper numeric conversion
            const currentCostToday = parseFloat(schedule.costToday) || 0;
            const generationCost = parseFloat(generationResult.cost) || 0;
            const newCostToday = currentCostToday + generationCost;
            
            // Calculate next topic index safely
            const topicsLength = schedule.topics?.length || 1;
            const currentIndex = schedule.nextTopicIndex || 0;
            const nextIndex = schedule.topicRotation === 'sequential' 
              ? (currentIndex + 1) % topicsLength 
              : currentIndex;
            
            await storage.updateAutoSchedule(schedule.id, {
              lastRun: now,
              postsThisMonth: (schedule.postsThisMonth || 0) + 1,
              costToday: newCostToday, // Now properly calculated as a number
              nextTopicIndex: nextIndex
            });
            
            console.log(`ðŸ’° Updated schedule costs: Previous: $${currentCostToday.toFixed(6)}, Generation: $${generationCost.toFixed(6)}, New Total: $${newCostToday.toFixed(6)}`);

            //nadagdag - Handle auto-publishing with proper scheduled_date field
            if (schedule.autoPublish) {
              //nadagdag - Calculate publish time based on delay
              let publishTime: Date;
              let scheduleStatus: string;
              
              if (schedule.publishDelay === 0 || !schedule.publishDelay) {
                //nadagdag - Immediate publishing
                publishTime = new Date();
                scheduleStatus = 'publishing';
                console.log(`ðŸ“Œ Setting up immediate publishing for content ${generationResult.contentId}`);
              } else {
                //nadagdag - Delayed publishing
                publishTime = new Date(
                  now.getTime() + (schedule.publishDelay || 0) * 60 * 60 * 1000
                );
                scheduleStatus = 'scheduled';
                console.log(`â° Scheduling content for ${publishTime.toISOString()}`);
              }

              //nadagdag - Create schedule data object
              const scheduleData = {
                contentId: generationResult.contentId,
                userId: schedule.userId,
                websiteId: schedule.websiteId,
                scheduled_date: publishTime,
                status: scheduleStatus,
                title: generationResult.title || topic || 'Auto-generated content',
                topic: topic,  //nadagdag - CRITICAL: Add topic as direct field (required by database)
                metadata: {
                  autoScheduleId: schedule.id,
                  autoScheduleName: schedule.name,
                  topic: topic,  // Keep in metadata too for reference
                  publishDelay: schedule.publishDelay || 0,
                  generatedAt: new Date(),
                  isAutoGenerated: true,
                },
              };

              //nadagdag - DEBUG: Log the data being sent
              console.log('ðŸ“‹ Creating content_schedule with data:', {
                contentId: scheduleData.contentId,
                userId: scheduleData.userId,
                websiteId: scheduleData.websiteId,
                scheduled_date: scheduleData.scheduled_date?.toISOString(),
                status: scheduleData.status,
                title: scheduleData.title,
                topic: scheduleData.topic,
              });

              try {
                //nadagdag - Create content_schedule ONLY ONCE
                await storage.createContentSchedule(scheduleData);
                console.log('âœ… Content schedule created successfully');
              } catch (dbError: any) {
                console.error('âŒ Database error when creating content_schedule:', dbError);
                console.error('Failed with data:', JSON.stringify(scheduleData, null, 2));
                throw dbError;
              }

              //nadagdag - If immediate publishing, trigger publish now
              if (schedule.publishDelay === 0) {
                try {
                  console.log(`ðŸš€ Attempting immediate publish for content ${generationResult.contentId}`);
                  
                  //nadagdag - Call WordPress publishing service
                  const publishResult = await this.publishToWordPress(
                    generationResult.contentId,
                    schedule.websiteId,
                    schedule.userId
                  );
                  
                  if (publishResult && publishResult.success) {
                    //nadagdag - Update content_schedule status to published
                    await storage.updateContentScheduleByContentId(generationResult.contentId, {
                      status: 'published',
                      published_at: new Date(),
                      metadata: {
                        wordPressPostId: publishResult.postId,
                        publishedAt: new Date().toISOString()
                      }
                    });
                    
                    console.log(`âœ… Content published immediately (WordPress Post ID: ${publishResult.postId})`);
                  } else {
                    //nadagdag - Update status to failed if publishing failed
                    await storage.updateContentScheduleByContentId(generationResult.contentId, {
                      status: 'failed',
                      error: publishResult?.error || 'Publishing failed'
                    });
                    
                    console.error(`âŒ Failed to publish immediately: ${publishResult?.error}`);
                  }
                } catch (publishError: any) {
                  console.error(`âŒ Publishing error: ${publishError.message}`);
                  
                  //nadagdag - Update status to failed on error
                  try {
                    await storage.updateContentScheduleByContentId(generationResult.contentId, {
                      status: 'failed',
                      error: publishError.message
                    });
                  } catch (updateError) {
                    console.error('Failed to update status:', updateError);
                  }
                }
              } else {
                console.log(`ðŸ“… Content scheduled for publishing at ${publishTime.toISOString()}`);
              }
            } else {
              //nadagdag - Not auto-publishing, save as draft
              console.log(`ðŸ“ Saving content ${generationResult.contentId} as draft`);
              
              const draftData = {
                contentId: generationResult.contentId,
                userId: schedule.userId,
                websiteId: schedule.websiteId,
                scheduled_date: new Date(),
                status: 'draft',
                title: generationResult.title || topic || 'Auto-generated draft',
                topic: topic,  //nadagdag - Add topic field for drafts too
                metadata: {
                  autoScheduleId: schedule.id,
                  autoScheduleName: schedule.name,
                  topic: topic,
                  isDraft: true,
                  generatedAt: new Date(),
                  isAutoGenerated: true,
                },
              };
              
              //nadagdag - DEBUG: Log draft data
              console.log('ðŸ“‹ Creating draft content_schedule with data:', {
                contentId: draftData.contentId,
                scheduled_date: draftData.scheduled_date?.toISOString(),
                title: draftData.title,
                topic: draftData.topic,
              });
              
              try {
                await storage.createContentSchedule(draftData);
                console.log('âœ… Draft schedule created successfully');
              } catch (dbError: any) {
                console.error('âŒ Database error when creating draft schedule:', dbError);
                console.error('Failed with data:', JSON.stringify(draftData, null, 2));
                throw dbError;
              }
            }

            // Log activity
            await storage.createActivityLog({
              userId: schedule.userId,
              websiteId: schedule.websiteId,
              type: "auto_content_generated",
              description: `Auto-generated content: "${topic}"`,
              metadata: {
                scheduleId: schedule.id,
                scheduleName: schedule.name,
                contentId: generationResult.contentId,
                cost: generationResult.cost,
                autoPublish: schedule.autoPublish,
                //nadagdag - Add publishing status to activity log
                publishStatus: schedule.autoPublish 
                  ? (schedule.publishDelay === 0 ? 'immediate' : 'scheduled')
                  : 'draft',
              },
            });

            results.push({
              scheduleId: schedule.id,
              success: true,
              contentId: generationResult.contentId,
              topic,
              cost: generationResult.cost,
              //nadagdag - Add publishing info to results
              published: schedule.autoPublish && schedule.publishDelay === 0,
              scheduled: schedule.autoPublish && schedule.publishDelay > 0,
            });
          } else {
            throw new Error(generationResult.error);
          }
        } catch (error) {
          console.error(`âŒ Failed to process schedule ${schedule.id}:`, error);

          await storage.createActivityLog({
            userId: schedule.userId,
            websiteId: schedule.websiteId,
            type: "auto_content_failed",
            description: `Failed to auto-generate content for: ${schedule.name}`,
            metadata: {
              scheduleId: schedule.id,
              error: error instanceof Error ? error.message : "Unknown error",
            },
          });

          results.push({
            scheduleId: schedule.id,
            success: false,
            error: error instanceof Error ? error.message : "Unknown error",
          });
        }
      }

      const generated = results.filter((r) => r.success).length;
      const failed = results.filter((r) => !r.success).length;

      console.log(
        `âœ… Auto-generation complete: ${generated} generated, ${failed} failed`
      );

      return {
        processed: results.length,
        generated,
        failed,
        results,
      };
    } finally {
      this.isProcessing = false;
    }
  }




























// Replace the publishToWordPress method in auto-schedule-service.ts with this:

// Replace the publishToWordPress method in auto-schedule-service.ts with this corrected version:

//nadagdag - WordPress REST API publishing using correct field names
// Corrected authentication in publishToWordPress method:

// Updated publishToWordPress method in auto-schedule-service.ts with immediate publishing

//nadagdag - WordPress REST API publishing with forced immediate publishing
// Updated publishToWordPress method in auto-schedule-service.ts with immediate publishing

private async publishToWordPress(
  contentId: string,
  websiteId: string,
  userId: string
): Promise<{ success: boolean; postId?: string; error?: string }> {
  try {
    // Step 1: Get the content from database
    const content = await storage.getContent(contentId);
    if (!content) {
      return { success: false, error: 'Content not found' };
    }
    
    // Step 2: Get the website details with WordPress credentials
    const website = await storage.getUserWebsite(websiteId, userId);
    if (!website) {
      return { success: false, error: 'Website not found' };
    }
    
    // Step 3: Validate WordPress configuration
    if (!website.url || !website.wpUsername || !website.wpApplicationPassword) {
      console.error('WordPress configuration missing:', {
        hasUrl: !!website.url,
        hasUsername: !!website.wpUsername,
        hasAppPassword: !!website.wpApplicationPassword
      });
      return { 
        success: false, 
        error: 'WordPress configuration incomplete. Please provide your WordPress username and application password.' 
      };
    }
    
    // Step 4: Prepare WordPress API endpoint
    const baseUrl = website.url.replace(/\/$/, '');
    const apiUrl = `${baseUrl}/wp-json/wp/v2/posts`;
    
    // Step 5: Prepare the post data
    const postData = {
      title: content.title,
      content: content.body || content.content || '',
      //nadagdag - ALWAYS publish immediately for auto-scheduled content
      status: 'publish', // Changed from conditional to always 'publish'
      excerpt: content.excerpt || '',
      format: 'standard',
      meta: {
        _yoast_wpseo_metadesc: content.metaDescription || content.meta_description || '',
        _yoast_wpseo_title: content.metaTitle || content.meta_title || content.title,
      }
    };
    
    // Step 6: Prepare authentication
    const auth = Buffer.from(
      `${website.wpUsername}:${website.wpApplicationPassword}`
    ).toString('base64');
    
    console.log(`ðŸ“¡ Publishing to WordPress: ${apiUrl}`);
    console.log(`ðŸ” Authenticating as WordPress user: ${website.wpUsername}`);
    console.log(`ðŸ“ Post title: ${postData.title}`);
    //nadagdag - Always shows 'publish' now
    console.log(`ðŸ“„ Status: ${postData.status} (forced immediate publishing)`);
    
    // Step 7: Make the API request
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Basic ${auth}`,
        'User-Agent': 'SEO-Content-Generator/1.0'
      },
      body: JSON.stringify(postData)
    });
    
    // Step 8: Handle the response
    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage = `WordPress API error: ${response.status} ${response.statusText}`;
      
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = errorJson.message || errorJson.code || errorMessage;
        
        if (response.status === 401) {
          errorMessage = `Authentication failed. Please check:
1. WordPress username: "${website.wpUsername}" is correct
2. Application password is valid and not expired
3. The application password has not been revoked in WordPress`;
        } else if (response.status === 403) {
          errorMessage = 'Permission denied. Make sure your WordPress user has permission to create posts.';
        } else if (response.status === 404) {
          errorMessage = 'WordPress REST API not found. Check if REST API is enabled and the URL is correct.';
        }
      } catch {
        errorMessage = errorText || errorMessage;
      }
      
      console.error('WordPress API error:', {
        status: response.status,
        statusText: response.statusText,
        error: errorMessage,
        url: apiUrl,
        username: website.wpUsername
      });
      
      return { success: false, error: errorMessage };
    }
    
    // Step 9: Parse successful response
    const publishedPost = await response.json();
    
    console.log(`âœ… Successfully published to WordPress:`, {
      postId: publishedPost.id,
      link: publishedPost.link,
      status: publishedPost.status
    });
    
    // Step 10: Update records
    try {
      // Update the content count for the website
      await storage.updateWebsite(websiteId, {
        contentCount: website.contentCount + 1,
        updatedAt: new Date()
      });
      
      // If you have a content update method
      if (typeof storage.updateContent === 'function') {
        await storage.updateContent(contentId, {
          wordpress_post_id: publishedPost.id.toString(),
          wordpress_link: publishedPost.link,
          published_at: new Date(),
          status: 'published'
        });
      }
    } catch (updateError) {
      console.warn('Could not update records:', updateError);
      // Don't fail the whole operation
    }
    
    // Step 11: Log the successful publication
    await storage.createActivityLog({
      userId: userId,
      websiteId: websiteId,
      type: 'content_published',
      description: `Published content to WordPress: "${content.title}"`,
      metadata: {
        contentId: contentId,
        wordpressPostId: publishedPost.id,
        wordpressLink: publishedPost.link,
        //nadagdag - Note that this was auto-published immediately
        autoPublished: true,
        publishedImmediately: true
      }
    });
    
    return {
      success: true,
      postId: publishedPost.id.toString()
    };
    
  } catch (error: any) {
    console.error('WordPress publishing error:', error);
    
    // Check for common network errors
    if (error.message?.includes('fetch failed')) {
      return { 
        success: false, 
        error: 'Could not connect to WordPress site. Please check the URL and ensure the site is accessible.' 
      };
    }
    
    return { 
      success: false, 
      error: error.message || 'Unknown publishing error' 
    };
  }
}

  private shouldRunSchedule(
    schedule: any,
    currentHour: number,
    currentDay: string
  ): boolean {
    // Check if it's time to run
    const scheduleHour = parseInt(schedule.timeOfDay.split(":")[0]);
    if (scheduleHour !== currentHour) return false;

    // Check if already run today
    if (schedule.lastRun) {
      const lastRunDate = new Date(schedule.lastRun).toDateString();
      const today = new Date().toDateString();
      if (lastRunDate === today) return false;
    }

    // Check frequency
    switch (schedule.frequency) {
      case "daily":
        return true;

      case "twice_weekly":
        return currentDay === "Monday" || currentDay === "Thursday";

      case "weekly":
        return currentDay === "Monday";

      case "biweekly":
        if (!schedule.lastRun) return currentDay === "Monday";
        const daysSinceLastRun = Math.floor(
          (Date.now() - new Date(schedule.lastRun).getTime()) /
            (1000 * 60 * 60 * 24)
        );
        return daysSinceLastRun >= 14 && currentDay === "Monday";

      case "monthly":
        const today = new Date().getDate();
        return today === 1;

      case "custom":
        const customDays = schedule.customDays || [];
        return customDays.includes(currentDay);

      default:
        return false;
    }
  }

  private selectTopic(schedule: any): string {
    const topics = schedule.topics || [];
    if (topics.length === 0) return "General content";

    if (schedule.topicRotation === "sequential") {
      const index = schedule.nextTopicIndex || 0;
      return topics[index % topics.length];
    } else {
      // Random selection
      return topics[Math.floor(Math.random() * topics.length)];
    }
  }

  //nabago
  async generateContent(schedule: any, topic: string): Promise<any> {
    try {
      // Safe handling of keywords field
      let keywordsArray: string[] = [];
      if (schedule.keywords) {
        if (Array.isArray(schedule.keywords)) {
          keywordsArray = schedule.keywords.filter((k: any) => k && typeof k === 'string');
        } else if (typeof schedule.keywords === 'string' && schedule.keywords.trim()) {
          keywordsArray = schedule.keywords.split(',').map((k: string) => k.trim()).filter(k => k);
        }
      }

      console.log('Processing keywords for schedule:', {
        scheduleId: schedule.id,
        originalKeywords: schedule.keywords,
        processedKeywords: keywordsArray,
        userId: schedule.userId
      });

      //nadagdag - Pass auto-publishing settings to AI service
      // Call the AI service to generate content
      const result = await aiService.generateContent({
        userId: schedule.userId, // CRITICAL: Pass userId
        websiteId: schedule.websiteId,
        topic: topic,
        keywords: keywordsArray,
        tone: schedule.tone || 'professional',
        wordCount: schedule.wordCount || 800,
        brandVoice: schedule.brandVoice || '',
        targetAudience: schedule.targetAudience || '',
        eatCompliance: schedule.eatCompliance || false,
        aiProvider: schedule.aiProvider || 'openai',
        includeImages: schedule.includeImages || false,
        imageCount: schedule.imageCount || 1,
        imageStyle: schedule.imageStyle || 'natural',
        seoOptimized: schedule.seoOptimized !== false,
        isAutoGenerated: true,
        autoScheduleId: schedule.id,
        //nadagdag - Pass auto-publish settings to AI service
        autoPublish: schedule.autoPublish || false,
        publishDelay: schedule.publishDelay || 0,
      });

      // Check if result has contentId (new format) or is the raw content (old format)
      if (result && result.contentId) {
        //nadagdag - New format with contentId and title
        // New format - AI service already saved the content
        return {
          success: true,
          contentId: result.contentId,
          cost: result.totalCost || 0,
          //nadagdag - Include title for use in content_schedule
          title: result.title
        };
      } else if (result && result.title && result.content) {
        // Old format - AI service returned raw content, we need to save it
        console.log('AI service returned raw content, saving to database...');
        
        // Save the generated content to the database
        const savedContent = await storage.createContent({
          userId: schedule.userId, // Use the schedule's userId
          websiteId: schedule.websiteId,
          title: result.title,
          body: result.content,
          excerpt: result.excerpt || '',
          metaDescription: result.metaDescription || '',
          metaTitle: result.metaTitle || result.title,
          aiModel: schedule.aiProvider || 'openai',
          seoKeywords: result.keywords || [],
          seoScore: result.seoScore || 0,
          readabilityScore: result.readabilityScore || 0,
          brandVoiceScore: result.brandVoiceScore || 0,
          eatCompliance: result.eatCompliance || false,
          tokensUsed: result.tokensUsed || 0,
          costUsd: Math.round((result.costUsd || 0) * 100), // Convert to cents for storage
          status: 'ready', // Auto-generated content can be marked as ready
          hasImages: schedule.includeImages || false,
          imageCount: schedule.imageCount || 0,
          imageCostCents: 0
        });

        console.log('Content saved with ID:', savedContent.id);

        return {
          success: true,
          contentId: savedContent.id,
          cost: result.costUsd || 0,
          //nadagdag - Include title for use in content_schedule
          title: result.title
        };
      } else {
        // No valid result
        console.error('Invalid result from AI service:', result);
        throw new Error('Content generation did not return valid content');
      }

    } catch (error) {
      console.error('Content generation error in auto-schedule:', {
        scheduleId: schedule.id,
        topic: topic,
        userId: schedule.userId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      
      return {
        success: false,
        error:
          error instanceof Error ? error.message : "Content generation failed",
      };
    }
  }

  // Reset daily costs at midnight
  async resetDailyCosts(): Promise<void> {
    console.log("ðŸ’° Resetting daily cost counters...");
    await storage.resetAutoScheduleDailyCosts();
  }

  // Reset monthly post counts at the start of each month
  async resetMonthlyCounts(): Promise<void> {
    console.log("ðŸ“Š Resetting monthly post counters...");
    await storage.resetAutoScheduleMonthlyCounts();
  }
}

export const autoScheduleService = new AutoScheduleService();
